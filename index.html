<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- SEO Meta Tags -->
<title>üè† Doupƒõ 2 - Survival Crafting</title>
<meta name="description" content="Ondrex's Ember Nidus - Doupe. Survival crafting game with real world assets features">
<meta name="keywords" content="doupe, doupƒõ, survival crafting game, ondrex, ondrex ember">
<meta name="author" content="Ondrex Ember">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://ondrex-ember.github.io/doupe-2/">

<link rel="icon" href="favicon.ico">
  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SZJL9L81VE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SZJL9L81VE');
</script>
<!-- Google Analytics -->
<!-- 
  ‚ö†Ô∏è CLIENT-SIDE GA4 NEFUNGUJE V APPS SCRIPT (iframe + cross-origin issues)
  Pou≈æ√≠v√°me SERVER-SIDE tracking p≈ôes Measurement Protocol API
  viz kod.gs -> trackEvent() funkce
-->
<!-- End Google Analytics -->

<script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "vct90i7r4t");
</script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Space+Mono:wght@400;700&display=swap');

* { 
  box-sizing: border-box; 
  margin: 0; 
  padding: 0; 
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-touch-callout: none;
}

html {
  /* Prevent iOS zoom on input focus */
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  /* Smooth scrolling for better UX */
  scroll-behavior: smooth;
  /* iOS safe area support */
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}

body {
  margin: 0;
  background: linear-gradient(135deg, #1a1410 0%, #2d2416 50%, #1a1410 100%);
  font-family: 'Crimson Pro', serif;
  color: #e8d5b7;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  min-height: -webkit-fill-available; /* iOS Safari fix */
  padding: 20px;
  position: relative;
  overflow-x: hidden;
  /* Better touch scrolling on iOS */
  -webkit-overflow-scrolling: touch;
  /* Prevent pull-to-refresh on mobile */
  overscroll-behavior-y: contain;
}

/* Prevent body scroll when modal is open */
body.modal-open {
  overflow: hidden;
  position: fixed;
  width: 100%;
  height: 100%;
}

@media (max-width: 768px) {
  body {
    padding: 10px 5px;
    align-items: flex-start;
    padding-top: 20px;
  }
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background: 
    radial-gradient(circle at 20% 30%, rgba(139, 90, 43, 0.1) 0%, transparent 50%),
    radial-gradient(circle at 80% 70%, rgba(87, 62, 38, 0.1) 0%, transparent 50%);
  pointer-events: none;
  animation: ambientGlow 15s ease-in-out infinite;
}

@keyframes ambientGlow {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 0.8; }
}

/* üî• EMBER LINK STYLING */
a {
  color: #d4a574;
  text-decoration: none;
  transition: all 0.3s ease;
  text-shadow: 0 0 8px rgba(255, 120, 40, 0.3);
  position: relative;
}

a:hover {
  color: #ff9944;
  text-shadow: 0 0 12px rgba(255, 120, 40, 0.8);
  animation: emberLinkGlow 1.5s ease-in-out infinite;
}

a:active {
  color: #ff7828;
}

@keyframes emberLinkGlow {
  0%, 100% { 
    text-shadow: 0 0 12px rgba(255, 120, 40, 0.8);
  }
  50% { 
    text-shadow: 0 0 16px rgba(255, 100, 20, 1);
  }
}

#game-container {
  width: 100%;
  max-width: 1000px;
  background: linear-gradient(145deg, rgba(44, 35, 25, 0.95), rgba(55, 42, 30, 0.95));
  border-radius: 24px;
  padding: 24px;
  box-shadow: 
    0 30px 80px rgba(0, 0, 0, 0.8),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
  border: 2px solid rgba(139, 90, 43, 0.3);
  position: relative;
  z-index: 1;
  animation: containerAppear 0.6s ease-out;
  /* Better touch handling */
  touch-action: pan-y;
  -webkit-tap-highlight-color: transparent;
}

@media (max-width: 768px) {
  #game-container {
    padding: 16px;
    border-radius: 16px;
    max-width: 100%;
    margin: 0 10px;
    /* Ensure proper touch scrolling */
    -webkit-overflow-scrolling: touch;
  }
}

@keyframes containerAppear {
  from {
    opacity: 0;
    transform: translateY(30px) scale(0.95);
  }
  to {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

#header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 2px solid rgba(139, 90, 43, 0.3);
  padding-bottom: 12px;
  margin-bottom: 16px;
}

@media (max-width: 768px) {
  #header {
    flex-wrap: wrap;
    gap: 10px;
  }
  
  #header h2 {
    font-size: 20px !important;
  }
  
  #header h3 {
    font-size: 11px !important;
    order: 3;
    flex-basis: 100%;
  }
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   FOOTER - Patiƒçka (mirror of header)
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

#footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-top: 2px solid rgba(139, 90, 43, 0.3);
  padding-top: 12px;
  margin-top: 16px;
}

@media (max-width: 768px) {
  #footer {
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    text-align: center;
  }
  
  #footer .footer-info {
    order: 3;
    flex-basis: 100%;
  }
  
  /* üéµ Mobile-friendly volume controls */
  #footer #music-toggle-btn {
    padding: 8px 12px !important;
    font-size: 18px !important;
  }
  
  #footer #volume-slider {
    width: 60px !important;
  }
  
  #footer #track-name {
    font-size: 11px !important;
  }
}

.footer-title {
  font-family: 'Space Mono', monospace;
  font-size: 14px;
  color: #d4a574;
  letter-spacing: 1px;
}

@media (max-width: 768px) {
  .footer-title {
    font-size: 13px;
  }
}

.footer-version {
  font-family: 'Crimson Pro', serif;
  font-size: 12px;
  color: #9a8670;
  font-style: italic;
}

@media (max-width: 768px) {
  .footer-version {
    font-size: 11px;
  }
}

.footer-info {
  text-align: right;
  font-family: 'Space Mono', monospace;
  font-size: 11px;
  color: #9a8670;
}

@media (max-width: 768px) {
  .footer-info {
    text-align: center;
    font-size: 10px;
  }
}

.footer-link {
  color: #d4a574;
  text-decoration: none;
  transition: color 0.2s ease;
  cursor: pointer;
}

.footer-link:hover {
  color: #e8c547;
  text-decoration: underline;
}

/* üå§Ô∏è WEATHER WIDGET */
.weather-widget {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-top: 8px;
  padding: 6px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-family: 'Space Mono', monospace;
  background: rgba(111, 180, 197, 0.15);
  border: 1px solid rgba(111, 180, 197, 0.3);
  transition: all 0.3s ease;
}

.weather-widget:hover {
  background: rgba(111, 180, 197, 0.25);
  transform: translateY(-1px);
}

.weather-icon {
  font-size: 16px;
  animation: weatherPulse 4s ease-in-out infinite;
}

@keyframes weatherPulse {
  0%, 100% { 
    opacity: 1;
    transform: scale(1);
  }
  50% { 
    opacity: 0.9;
    transform: scale(1.05);
  }
}

.weather-info {
  color: #b89968;
  font-size: 11px;
  font-weight: 600;
}

@media (max-width: 768px) {
  .weather-widget {
    font-size: 11px;
    padding: 5px 10px;
    margin-top: 6px;
  }
  
  .weather-icon {
    font-size: 14px;
  }
  
  .weather-info {
    font-size: 10px;
  }
}

/* Weather mode selector - minim√°ln√≠ styl */
.weather-mode-selector{display:inline-flex;gap:3px;margin-left:8px;padding:2px 4px;border-radius:6px;background:rgba(139,90,43,0.1);border:1px solid rgba(139,90,43,0.2)}
.weather-mode-btn{padding:3px 6px;border:none;border-radius:4px;background:transparent;color:#9a8670;font-size:16px;cursor:pointer;transition:all .2s;opacity:.5}
.weather-mode-btn:hover{opacity:.8;background:rgba(139,90,43,0.15)}
.weather-mode-btn.active{opacity:1;background:rgba(139,90,43,0.25)}
@media(max-width:768px){.weather-mode-selector{margin-left:4px;padding:2px 3px}.weather-mode-btn{font-size:14px;padding:2px 4px}}

#header h2 {
  font-family: 'Space Mono', monospace;
  font-size: 24px;
  color: #d4a574;
  text-shadow: 0 2px 8px rgba(212, 165, 116, 0.3);
  letter-spacing: 2px;
}

#header h3 {
  font-family: 'Crimson Pro', serif;
  font-size: 14px;
  color: #9a8670;
  font-style: italic;
  display: flex;
  align-items: center;
  gap: 6px;
}

.ember-icon {
  width: 28px;
  height: 28px;
  object-fit: contain;
  filter: drop-shadow(0 0 8px rgba(255, 120, 40, 0.6));
  animation: emberGlow 3s ease-in-out infinite;
}

@keyframes emberGlow {
  0%, 100% { filter: drop-shadow(0 0 8px rgba(255, 120, 40, 0.6)); }
  50% { filter: drop-shadow(0 0 12px rgba(255, 100, 20, 0.9)); }
}

.ember-icon-small {
  display: inline-block;
  font-size: 14px;
  filter: drop-shadow(0 0 6px rgba(255, 120, 40, 0.6));
  animation: emberGlow 3s ease-in-out infinite;
}

@media (max-width: 768px) {
  .ember-icon-small {
    font-size: 13px;
  }
}

#season-info {
  text-align: right;
  font-family: 'Space Mono', monospace;
}

@media (max-width: 768px) {
  #season-info {
    text-align: center;
  }
  
  #season-info .big {
    font-size: 18px !important;
  }
  
  #season-info .small {
    font-size: 11px !important;
  }
}

#season-info .big {
  font-size: 20px;
  font-weight: 700;
  color: #d4a574;
  display: block;
}

#season-info .small {
  font-size: 12px;
  color: #a08060;
  opacity: 0.8;
}
/* üî• FIRE INDICATOR STYLES */
.fire-indicator {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-top: 6px;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 11px;
  font-family: 'Space Mono', monospace;
  transition: all 0.3s ease;
}

.fire-indicator.active {
  background: rgba(255, 120, 40, 0.2);
  border: 1px solid rgba(255, 120, 40, 0.4);
}

.fire-indicator.active .fire-icon {
  animation: fireFlicker 1.5s ease-in-out infinite;
  filter: drop-shadow(0 0 6px rgba(255, 120, 40, 0.8));
}

.fire-indicator.active .fire-status {
  color: #ff9944;
  font-weight: 700;
}

.fire-indicator.inactive {
  background: rgba(60, 50, 40, 0.3);
  border: 1px solid rgba(100, 80, 60, 0.2);
  opacity: 0.5;
}

.fire-indicator.inactive .fire-icon {
  filter: grayscale(100%) brightness(0.7);
}

.fire-indicator.inactive .fire-status {
  color: #6a5d4f;
}

@keyframes fireFlicker {
  0%, 100% { 
    opacity: 1; 
    transform: scale(1);
  }
  50% { 
    opacity: 0.85;
    transform: scale(1.05);
  }
}

@media (max-width: 768px) {
  .fire-indicator {
    font-size: 10px;
    padding: 3px 8px;
  }
}

/* üí∞ GOLD DISPLAY STYLES */
.gold-display {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  margin-top: 6px;
  padding: 5px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-family: 'Space Mono', monospace;
  background: rgba(212, 165, 116, 0.15);
  border: 1px solid rgba(212, 165, 116, 0.4);
  transition: all 0.3s ease;
}

.gold-display:hover {
  background: rgba(212, 165, 116, 0.25);
  transform: translateY(-1px);
}

.gold-icon {
  font-size: 14px;
  animation: goldShine 3s ease-in-out infinite;
}

@keyframes goldShine {
  0%, 100% { 
    filter: drop-shadow(0 0 4px rgba(255, 215, 0, 0.6));
  }
  50% { 
    filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.9));
  }
}

.gold-amount {
  color: #d4a574;
  font-weight: 700;
  font-size: 13px;
}

@media (max-width: 768px) {
  .gold-display {
    font-size: 11px;
    padding: 4px 10px;
  }
  
  .gold-amount {
    font-size: 12px;
  }
}

#status-bars {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 12px;
  margin: 16px 0;
}

@media (max-width: 768px) {
  #status-bars {
    grid-template-columns: 1fr;
  }
}

.bar {
  background: rgba(30, 24, 18, 0.6);
  border-radius: 10px;
  padding: 10px 12px;
  border: 1px solid rgba(139, 90, 43, 0.2);
  transition: all 0.3s ease;
}

.bar:hover {
  border-color: rgba(139, 90, 43, 0.4);
  transform: translateY(-2px);
}

.bar-label {
  font-size: 13px;
  margin-bottom: 6px;
  font-weight: 600;
  color: #b89968;
}

@media (max-width: 768px) {
  .bar-label {
    font-size: 14px;
  }
  
  .bar {
    padding: 12px 14px !important;
  }
  
  .fill-container {
    height: 28px !important;
  }
  
  .fill {
    font-size: 13px !important;
  }
}

.fill-container {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  height: 24px;
  overflow: hidden;
  position: relative;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
}

.fill {
  height: 100%;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  font-family: 'Space Mono', monospace;
}

.fill::after {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
  border-radius: 6px;
}

.hunger {
  background: linear-gradient(90deg, #c0504d 0%, #e67e7b 100%);
  color: #fff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.water {
  background: linear-gradient(90deg, #4a90a4 0%, #6fb4c5 100%);
  color: #fff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.temperature {
  background: linear-gradient(90deg, #4a90e4 0%, #6fb4c5 35%, #7bc876 50%, #e8c547 65%, #e67e7b 100%);
  color: #fff;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  font-weight: 700;
}

#log {
  background: rgba(20, 16, 12, 0.7);
  border-radius: 12px;
  padding: 12px;
  height: 140px;
  overflow-y: auto;
  margin-bottom: 16px;
  border: 1px solid rgba(139, 90, 43, 0.2);
  font-family: 'Space Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.5);
  /* Better touch scrolling */
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

@media (max-width: 768px) {
  #log {
    height: 120px;
    font-size: 11px;
    padding: 10px;
    /* Ensure smooth scrolling on touch */
    scroll-behavior: smooth;
  }
}

#log::-webkit-scrollbar {
  width: 8px;
}

#log::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 4px;
}

#log::-webkit-scrollbar-thumb {
  background: rgba(139, 90, 43, 0.4);
  border-radius: 4px;
}

#log::-webkit-scrollbar-thumb:hover {
  background: rgba(139, 90, 43, 0.6);
}

.log-entry {
  margin-bottom: 6px;
  padding: 3px 6px;
  border-radius: 3px;
  animation: logAppear 0.3s ease-out;
}

@keyframes logAppear {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.log-info { color: #b8b0a0; background: rgba(184, 176, 160, 0.05); }
.log-warning { color: #e8c547; background: rgba(232, 197, 71, 0.1); }
.log-danger { color: #e67e7b; background: rgba(230, 126, 123, 0.1); }
.log-item { color: #6fb4c5; background: rgba(111, 180, 197, 0.1); }
.log-success { color: #7bc876; background: rgba(123, 200, 118, 0.1); }

.two-column-layout {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 15px;
  margin-bottom: 15px;
}

.two-column-layout .section {
  margin-bottom: 0;
}

@media (max-width: 768px) {
  .two-column-layout {
    grid-template-columns: 1fr;
  }
}

.section {
  background: rgba(40, 32, 24, 0.5);
  border-radius: 12px;
  padding: 12px;
  margin-bottom: 15px;
  border: 1px solid rgba(139, 90, 43, 0.2);
}

.section-title {
  font-size: 16px;
  font-weight: 700;
  color: #d4a574;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 6px;
}

@media (max-width: 768px) {
  .section-title {
    font-size: 17px;
  }
  
  .section {
    padding: 14px !important;
  }
}

.section-title .icon {
  font-size: 18px;
}

.section-content {
  display: grid;
  gap: 6px;
}

/* Crafting recipes: 3-column tile layout */
#recipes {
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}

@media (max-width: 1024px) {
  #recipes {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  #recipes {
    /* üé® MOBILE: 3 dla≈ædice vedle sebe m√≠sto 1 sloupce */
    grid-template-columns: repeat(3, 1fr);
    gap: 8px; /* Men≈°√≠ mezery na mobilu */
  }
}

/* üì± EXTRA SMALL: Pro velmi mal√© displeje (iPhone SE, atd.) */
@media (max-width: 375px) {
  #recipes {
    grid-template-columns: repeat(2, 1fr); /* 2 sloupce na mini displej√≠ch */
    gap: 6px;
  }
}

.item-card {
  display: flex;
  align-items: center;
  gap: 10px;
  background: rgba(20, 16, 12, 0.6);
  padding: 10px 12px;
  border-radius: 8px;
  border: 1px solid rgba(139, 90, 43, 0.15);
  transition: all 0.2s ease;
  animation: itemAppear 0.4s ease-out;
}

@media (max-width: 768px) {
  .item-card {
    padding: 12px 14px;
    gap: 12px;
  }
  
  .item-icon {
    font-size: 28px !important;
  }
  
  .item-name {
    font-size: 15px !important;
  }
  
  .item-count {
    font-size: 16px !important;
  }
}

@keyframes itemAppear {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.item-card:hover {
  border-color: rgba(139, 90, 43, 0.4);
  transform: translateX(4px);
  background: rgba(30, 24, 18, 0.7);
}

.item-icon {
  font-size: 24px;
  line-height: 1;
  flex-shrink: 0;
}

.item-details {
  flex: 1;
  min-width: 0;
}

.item-name {
  font-weight: 700;
  font-size: 14px;
  color: #d4a574;
  margin-bottom: 2px;
}

.item-desc {
  font-size: 11px;
  color: #9a8670;
  font-style: italic;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.item-count {
  font-weight: 700;
  font-size: 15px;
  color: #b89968;
  font-family: 'Space Mono', monospace;
  margin-left: auto;
  flex-shrink: 0;
}

/* üí∞ ECONOMY: Sell & Buy Buttons */
.item-action-btn {
  padding: 5px 10px;
  font-size: 11px;
  font-weight: 700;
  font-family: 'Space Mono', monospace;
  border: none;
  border-radius: 6px;
  margin-left: 8px;
  transition: all 0.2s ease;
  cursor: pointer;
  flex-shrink: 0;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.item-sell-btn {
  background: linear-gradient(135deg, #d4a574, #c9a576);
  color: #1a1410;
  border: 1px solid rgba(212, 165, 116, 0.6);
  box-shadow: 0 2px 4px rgba(212, 165, 116, 0.3);
}

.item-sell-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(212, 165, 116, 0.5);
}

.item-sell-btn:active {
  transform: translateY(0);
  opacity: 0.8;
}

.item-buy-btn {
  background: linear-gradient(135deg, #7bc876, #6fb865);
  color: #fff;
  border: 1px solid rgba(123, 200, 118, 0.6);
  box-shadow: 0 2px 4px rgba(123, 200, 118, 0.3);
}

.item-buy-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(123, 200, 118, 0.5);
}

.item-buy-btn:active {
  transform: translateY(0);
  opacity: 0.8;
}

.item-action-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
}

.item-action-btn .price-tag {
  font-size: 10px;
  opacity: 0.9;
}

@media (max-width: 768px) {
  .item-action-btn {
    padding: 6px 12px;
    font-size: 12px;
    min-height: 32px;
  }
}

.recipe-card {
  background: rgba(20, 16, 12, 0.6);
  padding: 12px;
  border-radius: 10px;
  border: 1px solid rgba(139, 90, 43, 0.15);
  transition: all 0.2s ease;
  cursor: pointer;
  min-height: 90px;
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
  justify-content: space-between;
}

@media (max-width: 768px) {
  .recipe-card {
    padding: 8px 6px; /* Kompaktnƒõj≈°√≠ padding */
    min-height: 90px; /* Zachovat min v√Ω≈°ku */
    font-size: 11px; /* Men≈°√≠ text */
  }
  
  .recipe-icon {
    font-size: 24px !important; /* Vƒõt≈°√≠ ikona pro lep≈°√≠ ƒçitelnost */
  }
  
  .recipe-name {
    font-size: 11px !important; /* Men≈°√≠ n√°zev */
    line-height: 1.2;
  }
  
  .recipe-materials {
    font-size: 9px !important; /* Men≈°√≠ materi√°ly */
    line-height: 1.3;
  }
}

.recipe-card.can-craft {
  border-color: rgba(123, 200, 118, 0.4);
}

.recipe-card.can-craft:hover {
  border-color: rgba(123, 200, 118, 0.6);
  transform: translateY(-3px) scale(1.02);
  background: rgba(123, 200, 118, 0.1);
  box-shadow: 0 6px 12px rgba(123, 200, 118, 0.2);
}

.recipe-card.cannot-craft {
  opacity: 0.4;
  cursor: default;
}

.recipe-header {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
}

.recipe-icon {
  font-size: 24px;
  flex-shrink: 0;
}

.recipe-name {
  font-weight: 700;
  font-size: 13px;
  color: #d4a574;
}

.recipe-materials {
  font-size: 10px;
  color: #9a8670;
  font-family: 'Space Mono', monospace;
  padding: 0;
  margin-top: auto;
}

.entity-card {
  background: rgba(20, 16, 12, 0.6);
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(139, 90, 43, 0.15);
  animation: entityAppear 0.5s ease-out;
}

@keyframes entityAppear {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.entity-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 8px;
}

.entity-icon {
  font-size: 28px;
  flex-shrink: 0;
}

.entity-info {
  flex: 1;
  min-width: 0;
}

.entity-name {
  font-weight: 700;
  font-size: 15px;
  color: #d4a574;
}

.entity-status {
  font-size: 11px;
  color: #9a8670;
  font-family: 'Space Mono', monospace;
}

.entity-actions {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.entity-action-btn {
  flex: 1;
  padding: 5px 10px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 11px;
  font-family: 'Space Mono', monospace;
  font-weight: 700;
  transition: all 0.2s ease;
  background: rgba(139, 90, 43, 0.3);
  color: #d4a574;
  border: 1px solid rgba(139, 90, 43, 0.4);
}

@media (max-width: 768px) {
  .entity-action-btn {
    padding: 10px 12px;
    font-size: 12px;
    min-height: 42px;
  }
  
  .entity-actions {
    flex-wrap: wrap;
    gap: 8px !important;
  }
  
  .entity-action-btn {
    flex: 1 1 calc(50% - 4px);
    min-width: 120px;
  }
}

.entity-action-btn:hover {
  background: rgba(139, 90, 43, 0.5);
  transform: translateY(-2px);
}

.entity-action-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
  transform: none;
}

.controls {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 15px;
  flex-wrap: wrap;
}

@media (max-width: 768px) {
  .controls {
    gap: 8px;
  }
  
  .controls button {
    flex: 1 1 auto;
    min-width: 140px;
  }
}

button {
  padding: 12px 22px;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 700;
  font-family: 'Space Mono', monospace;
  transition: all 0.2s ease;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  /* Better touch handling */
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
  user-select: none;
  -webkit-user-select: none;
}

@media (max-width: 768px) {
  button {
    padding: 14px 20px;
    font-size: 15px;
    min-height: 48px;
    /* Increase touch target size */
    min-width: 48px;
  }
}

button:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
}

button:active {
  transform: translateY(-1px);
  /* Visual feedback on touch */
  opacity: 0.8;
}

.primary {
  background: linear-gradient(135deg, #8b5a2b 0%, #a67c52 100%);
  color: #fff;
  border: 1px solid rgba(212, 165, 116, 0.3);
}

.primary:hover {
  background: linear-gradient(135deg, #a67c52 0%, #c9a576 100%);
}

.danger {
  background: linear-gradient(135deg, #c0504d 0%, #e67e7b 100%);
  color: #fff;
  border: 1px solid rgba(230, 126, 123, 0.3);
}

.danger:hover {
  background: linear-gradient(135deg, #e67e7b 0%, #f29b98 100%);
}

.event-notification {
  position: fixed;
  top: 20px;
  right: 20px;
  background: linear-gradient(135deg, rgba(139, 90, 43, 0.95), rgba(166, 124, 82, 0.95));
  border-radius: 12px;
  padding: 16px 20px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
  border: 2px solid rgba(212, 165, 116, 0.4);
  animation: slideIn 0.5s ease-out;
  z-index: 1000;
  max-width: 300px;
  font-family: 'Space Mono', monospace;
  font-size: 14px;
  color: #fff;
}

@media (max-width: 768px) {
  .event-notification {
    top: 10px;
    right: 10px;
    left: 10px;
    max-width: none;
    font-size: 13px;
    padding: 12px 16px;
  }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(100%);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.empty-state {
  text-align: center;
  padding: 15px;
  color: #6a5d4f;
  font-style: italic;
  font-size: 13px;
}

.season-indicator {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 700;
  margin-left: 8px;
}

.season-spring { background: rgba(123, 200, 118, 0.2); color: #7bc876; }
.season-summer { background: rgba(232, 197, 71, 0.2); color: #e8c547; }
.season-autumn { background: rgba(212, 165, 116, 0.2); color: #d4a574; }
.season-winter { background: rgba(111, 180, 197, 0.2); color: #6fb4c5; }

/* Leaderboard & Nickname Modals */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.9);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  animation: fadeIn 0.3s ease-out;
  /* Prevent scroll behind modal */
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  /* Prevent body scroll leak */
  overscroll-behavior: contain;
}

.modal-content {
  background: linear-gradient(145deg, #2c231a, #372a1e);
  border-radius: 20px;
  padding: 30px;
  max-width: 600px;
  width: 90%;
  border: 2px solid rgba(139, 90, 43, 0.4);
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
  animation: scaleIn 0.4s ease-out;
  max-height: 90vh;
  overflow-y: auto;
  /* Better scrolling on touch devices */
  -webkit-overflow-scrolling: touch;
  /* Prevent margin collapse */
  position: relative;
}

@media (max-width: 768px) {
  .modal-content {
    padding: 20px;
    width: 95%;
    border-radius: 16px;
  }
  
  .modal-title {
    font-size: 22px !important;
  }
  
  .leaderboard-table {
    font-size: 13px !important;
  }
  
  .leaderboard-table th,
  .leaderboard-table td {
    padding: 8px 6px !important;
  }
  
  .rank-badge {
    width: 26px !important;
    height: 26px !important;
    line-height: 26px !important;
    font-size: 12px !important;
  }
  
  .modal-btn {
    padding: 12px 18px !important;
    font-size: 13px !important;
  }
  
  .nickname-input {
    font-size: 15px !important;
  }
}

.modal-title {
  font-family: 'Space Mono', monospace;
  font-size: 28px;
  color: #d4a574;
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 2px 8px rgba(212, 165, 116, 0.3);
}

.nickname-input {
  width: 100%;
  padding: 12px 16px;
  font-size: 16px; /* iOS needs 16px+ to prevent auto-zoom */
  font-family: 'Crimson Pro', serif;
  background: rgba(20, 16, 12, 0.8);
  border: 2px solid rgba(139, 90, 43, 0.3);
  border-radius: 10px;
  color: #e8d5b7;
  margin: 15px 0;
  transition: border-color 0.2s;
}

.nickname-input:focus {
  outline: none;
  border-color: rgba(139, 90, 43, 0.6);
}

.nickname-info {
  text-align: center;
  color: #b89968;
  font-size: 14px;
  margin: 10px 0;
}

.leaderboard-table {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}

.leaderboard-table th {
  background: rgba(139, 90, 43, 0.2);
  padding: 12px;
  text-align: left;
  font-family: 'Space Mono', monospace;
  font-size: 13px;
  color: #d4a574;
  border-bottom: 2px solid rgba(139, 90, 43, 0.3);
}

.leaderboard-table td {
  padding: 10px 12px;
  border-bottom: 1px solid rgba(139, 90, 43, 0.1);
  font-size: 14px;
}

.leaderboard-table tr:hover {
  background: rgba(139, 90, 43, 0.1);
}

.rank-badge {
  display: inline-block;
  width: 30px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  border-radius: 50%;
  font-weight: 700;
  font-family: 'Space Mono', monospace;
}

.rank-1 { background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; }
.rank-2 { background: linear-gradient(135deg, #C0C0C0, #808080); color: #000; }
.rank-3 { background: linear-gradient(135deg, #CD7F32, #8B4513); color: #fff; }
.rank-other { background: rgba(139, 90, 43, 0.2); color: #b89968; }

.modal-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
  margin-top: 20px;
}

.modal-btn {
  padding: 12px 24px;
  border: none;
  border-radius: 10px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 700;
  font-family: 'Space Mono', monospace;
  transition: all 0.2s ease;
}

.modal-btn-primary {
  background: linear-gradient(135deg, #8b5a2b, #a67c52);
  color: #fff;
  border: 1px solid rgba(212, 165, 116, 0.3);
}

.modal-btn-primary:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
}
.modal-btn-secondary {
  background: rgba(139, 90, 43, 0.2);
  color: #d4a574;
  border: 1px solid rgba(139, 90, 43, 0.3);
}

.modal-btn-secondary:hover {
  background: rgba(139, 90, 43, 0.3);
}

.your-rank {
  background: rgba(123, 200, 118, 0.2) !important;
  border-left: 3px solid #7bc876;
}
/* Music toggle button styles */
#music-toggle {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 10000;
}

/* üéµ Scroll animation for track name */
@keyframes scrollText {
  0% { transform: translateX(0); }
  100% { transform: translateX(-50%); }
}

</style>
</head>

<body>
<div id="game-container">

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ‚ö†Ô∏è CRITICAL SECTION - HEADER
       Hlaviƒçka s n√°zvem, sez√≥nou, fire indicator a gold display
       Required: day, season, fire-indicator, gold-display
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="header">
    <h1>üè† DOUPƒö</h1>
    <h3></h3>
    <div id="season-info">
      <span class="big">Den <span id="day">1</span></span>
      <span class="small"><span id="season">Jaro</span></span>
      <!-- Weather mode selector -->
      <span class="weather-mode-selector">
        <button class="weather-mode-btn active" data-mode="game" onclick="game.setWeatherMode('game')" title="Hra">üéÆ</button>
        <button class="weather-mode-btn" data-mode="openmeteo" onclick="game.setWeatherMode('openmeteo')" title="Open-Meteo">üåç</button>
        <button class="weather-mode-btn" data-mode="weatherxm" onclick="game.setWeatherMode('weatherxm')" title="WeatherXM">üì°</button>
      </span>
      <!-- üî• FIRE INDICATOR -->
      <span class="fire-indicator inactive" id="fire-indicator">
        <span class="fire-icon">üî•</span>
        <span class="fire-status">Bez ohnƒõ</span>
      </span>
      <!-- üí∞ GOLD DISPLAY -->
      <span class="gold-display" id="gold-display">
        <span class="gold-icon">üí∞</span>
        <span class="gold-amount" id="gold-amount">0</span>
      </span>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ‚ö†Ô∏è CRITICAL SECTION - STATUS BARS
       Z√°soby j√≠dla, vody a teplota - CORE gameplay mechanic
       Required: hunger-fill, water-fill, temp-fill
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="status-bars">
    <div class="bar">
      <div class="bar-label">üçñ Z√°soby j√≠dla</div>
      <div class="fill-container">
        <div class="fill hunger" id="hunger-fill" style="width: 100%;">50 (10d)</div>
      </div>
    </div>
    <div class="bar">
      <div class="bar-label">üíß Z√°soby vody</div>
      <div class="fill-container">
        <div class="fill water" id="water-fill" style="width: 100%;">50 (16d)</div>
      </div>
    </div>
    <div class="bar">
      <div class="fill-container">
        <div class="fill temperature" id="temp-fill" style="width: 50%;">15¬∞C</div>
      </div>
      <div class="bar-label"><span id="temp-emoji">üå°Ô∏è</span> Teplota doupƒõte</div>
    </div>
  </div>

  <div id="log"></div>

  <div class="two-column-layout">
    <div class="section">
      <div class="section-title">
        <span class="icon">üì¶</span>
        <span>Invent√°≈ô</span>
      </div>
      <div class="section-content" id="inventory"></div>
    </div>

    <div class="section">
      <div class="section-title">
        <span class="icon">üî®</span>
        <span>Crafting recepty</span>
      </div>
      <div class="section-content" id="recipes"></div>
    </div>
  </div>

  <div class="section" id="entities-section" style="display: none;">
    <div class="section-title">
      <span class="icon">üë•</span>
      <span>Obyvatel√© doupƒõte</span>
    </div>
    <div class="section-content" id="entities"></div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ‚ö†Ô∏è CRITICAL SECTION - MAIN CONTROLS
       Hlavn√≠ hern√≠ tlaƒç√≠tka - NESM√ç ZMIZET!
       Required: nextDay, saveGame, showLeaderboard, reset
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div class="controls">
    <button class="primary" onclick="game.nextDay()">‚è∞ Dal≈°√≠ den</button>
    <button class="primary" onclick="game.saveGame()">üíæ Ulo≈æit hru</button>
    <button class="primary" onclick="game.showLeaderboard()">üèÜ ≈Ωeb≈ô√≠ƒçek</button>
    <button class="danger" onclick="game.reset()">üîÑ Nov√Ω zaƒç√°tek</button>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       ‚ö†Ô∏è CRITICAL SECTION - FOOTER
       Patiƒçka s live statistikami a d≈Øle≈æit√Ωmi odkazy
       Required: footer-stats, loadGame, showLeaderboard, showAbout
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="footer">
    <div>
      <span class="footer-title">üè† DOUPƒö v2.12m</span>
      <br>
      <!-- üå§Ô∏è WEATHER WIDGET -->
      <span class="weather-widget" id="weather-widget">
        <span class="weather-icon">üå§Ô∏è</span>
        <span class="weather-info">Naƒç√≠t√°m poƒças√≠...</span>
      </span>
      <p></p>
      <span class="footer-version"> ‚Ä¢ by Ondrex's <a href="https://www.ember-pa.cz">Ember<span class="ember-icon-small">üî•</span></a></span>
      <br>
      <span class="footer-version"><a href="https://ondrex-ember.github.io/tech-1000-piv/"> ‚Ä¢ Tƒõch 1000 piv üç∫ s Ondrexem</a></span>
      
      <!-- üéµ SOUND CONTROL -->
      <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
        <button id="music-toggle-btn" 
          onclick="toggleAllAudio()"
          style="
            background: rgba(139, 90, 43, 0.3);
            border: 1px solid rgba(212, 165, 116, 0.4);
            color: #d4a574;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
          "
          onmouseover="this.style.background='rgba(139, 90, 43, 0.5)'"
          onmouseout="this.style.background='rgba(139, 90, 43, 0.3)'"
        >
          üîä
        </button>
        <button id="next-track-btn" 
		  onclick="if(window.atmosphericMusic) window.atmosphericMusic.nextTrack()"
          title="Dal≈°√≠ skladba"
          style="
			  background: rgba(139, 90, 43, 0.3);
			  border: 1px solid rgba(212, 165, 116, 0.4);
			  color: #d4a574;
			  padding: 6px 10px;
			  border-radius: 6px;
			  cursor: pointer;
			  font-size: 16px;
			  font-family: 'Space Mono', monospace;
			  transition: all 0.3s;
			"
			onmouseover="this.style.background='rgba(139, 90, 43, 0.5)'"
			onmouseout="this.style.background='rgba(139, 90, 43, 0.3)'"
		>
        >>
      </button>
        <div style="
          flex: 1;
          overflow: hidden;
          background: rgba(40, 32, 24, 0.4);
          border-radius: 6px;
          padding: 6px 10px;
          border: 1px solid rgba(139, 90, 43, 0.3);
          min-width: 150px;
          max-width: 300px;
        ">
          <div id="track-name" style="
            color: #d4a574;
            font-size: 12px;
            white-space: nowrap;
            animation: scrollText 15s linear infinite;
          ">
            üéµ Zat√≠m ticho...
          </div>
        </div>
        
        <input 
          type="range" 
          id="volume-slider"
          min="0" 
          max="100" 
          value="13"
          oninput="if(window.atmosphericMusic) atmosphericMusic.setVolume(this.value)"
          style="
            width: 80px;
            accent-color: #d4a574;
          "
        >
        <span id="volume-label" style="color: #9a8670; font-size: 12px; min-width: 35px;">30%</span>
      </div>
    </div>
    <div class="footer-info">
      <span id="footer-stats">Kolonie: 1 üë• | Rekord: <span id="footer-best-run">0</span>d</span>
      <br>
      <span class="footer-link" onclick="game.loadGame()">üìÇ Naƒç√≠st</span>
      <span style="opacity: 0.5;"> ‚Ä¢ </span>
      <span class="footer-link" onclick="game.showLeaderboard()">üìä ≈Ωeb≈ô√≠ƒçek</span>
      <span style="opacity: 0.5;"> ‚Ä¢ </span>
      <span class="footer-link" onclick="game.showAbout()">‚ÑπÔ∏è O h≈ôe</span>
    </div>
  </div>

</div>

<script>
const game = {

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ö†Ô∏è CRITICAL FUNCTION - MODAL MANAGEMENT
  // V≈°echny modal funkce MUS√ç volat openModal() a closeModal()!
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  /**
   * üîí OPEN MODAL
   * 
   * Zamkne body scroll a ulo≈æ√≠ pozici scrollu.
   * ‚ö†Ô∏è MUS√ç b√Ωt vol√°no p≈ôed zobrazen√≠m ka≈æd√©ho modalu!
   * 
   * @returns {void}
   * @sideeffects Adds 'modal-open' class, locks scroll, stores scroll position
   * 
   * @example
   * game.openModal(); // V≈ædy prvn√≠ ≈ô√°dek v show*Modal() funkci
   * 
   * @see closeModal() - Pro odemknut√≠ scrollu
   */
  openModal() {
    // Lock body scroll when modal opens
    document.body.classList.add('modal-open');
    // Store scroll position
    this._scrollY = window.scrollY;
    document.body.style.top = `-${this._scrollY}px`;
  },

  /**
   * üîì CLOSE MODAL
   * 
   * Odstran√≠ modal z DOM a odemkne body scroll.
   * ‚ö†Ô∏è MUS√ç b√Ωt vol√°no p≈ôi zav√≠r√°n√≠ ka≈æd√©ho modalu!
   * 
   * @param {string} modalId - ID modalu k odstranƒõn√≠ (bez #)
   * @returns {void}
   * @sideeffects Removes modal, unlocks scroll, restores scroll position
   * 
   * @example
   * game.closeModal('leaderboard-modal');
   * 
   * @see openModal() - Pro zamknut√≠ scrollu
   */
  closeModal(modalId) {
    // Remove modal
    const modal = document.getElementById(modalId);
    if (modal) modal.remove();
    
    // Unlock body scroll
    document.body.classList.remove('modal-open');
    document.body.style.top = '';
    
    // Restore scroll position
    if (this._scrollY !== undefined) {
      window.scrollTo(0, this._scrollY);
      this._scrollY = undefined;
    }
  },

  // üåê HYBRID BACKEND ADAPTER
  // Automatically detects environment and uses appropriate backend method
  
  // ‚ö†Ô∏è IMPORTANT: Replace with your actual Apps Script Web App URL
  BACKEND_API_URL: 'https://script.google.com/macros/s/AKfycbwWqpMUKiT6iS6NwVYP7GM2MBD1IqCMhLToAhVVPtsl2IIvuk6IoHuFlzlTtVVY551v/exec',
  
  get isAppsScript() {
    // Check if we're running in Apps Script environment
    return typeof google !== 'undefined' && 
           google.script && 
           google.script.run;
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üîß UPDATED BACKEND FUNCTION - Pou≈æij GET m√≠sto POST (CORS fix)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Najdi v index.html funkci backend() (cca ≈ô√°dek 1360)
// a NAHRAƒé JI t√≠mto:

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// üîß UPDATED BACKEND FUNCTION - JSONP pro CORS fix
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// V index.html najdi funkci backend() a NAHRAƒé JI celou t√≠mto:

async backend(functionName, data = null) {
  // Apps Script environment - use google.script.run (direct)
  if (this.isAppsScript) {
    return new Promise((resolve, reject) => {
      try {
        const runner = google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(reject);
        
        if (data !== null) {
          runner[functionName](data);
        } else {
          runner[functionName]();
        }
      } catch(error) {
        reject(error);
      }
    });
  }
  
  // GitHub environment - USE JSONP (CORS workaround)
  return new Promise((resolve, reject) => {
    try {
      console.log(`üåê JSONP call: ${functionName}`, data ? `with data` : 'no data');
      
      // Timeout pro detekci zatuhl√©ho vol√°n√≠
      const timeout = setTimeout(() => {
        console.error(`‚è±Ô∏è JSONP timeout after 30s: ${functionName}`);
        cleanup();
        reject(new Error(`API timeout after 30s: ${functionName}`));
      }, 30000); // 30s timeout
      
      // Generate unique callback name
      const callbackName = 'jsonp_callback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      let script;
      
      const cleanup = () => {
        clearTimeout(timeout);
        if (window[callbackName]) {
          delete window[callbackName];
        }
        if (script && script.parentNode) {
          document.body.removeChild(script);
        }
      };
      
      // Create global callback function
      window[callbackName] = function(response) {
        console.log(`‚úÖ JSONP response from ${functionName}:`, response);
        cleanup();
        resolve(response);
      };
      
      // Build URL with params
      const params = new URLSearchParams({
        action: functionName,
        data: JSON.stringify(data || {}),
        callback: callbackName
      });
      
      const url = `${this.BACKEND_API_URL}?${params}`;
      console.log(`üì° JSONP URL:`, url.substring(0, 150) + '...');
      
      // Create script tag for JSONP
      script = document.createElement('script');
      script.src = url;
      script.onerror = function(e) {
        console.error(`‚ùå JSONP script load failed: ${functionName}`, e);
        cleanup();
        
        // Return mock success for non-critical functions
        if (functionName === 'trackEvent') {
          resolve({ success: true, message: 'Tracking skipped (API unavailable)' });
        } else if (functionName === 'logTransaction') {
          resolve({ success: true, message: 'Transaction logging skipped (API unavailable)' });
        } else {
          reject(new Error(`JSONP script load failed: ${functionName}`));
        }
      };
      
      // Add script to page
      document.body.appendChild(script);
      
    } catch(error) {
      console.error(`‚ùå JSONP call exception:`, error);
      reject(error);
    }
  });
},
  state: {
    day: 1,
    season: 0,
    dead: false,
    inventory: {},
    entities: [],
    unlockedRecipes: [],
    eventChance: 0.5,
    temperature: 15,
    shelterLevel: 1,
    heating: 0,
    guaranteedStones: 0,
    playerId: null,
    playerNickname: null,
    bestRun: 0,
    // üî• FIRE SYSTEM
    fireActive: false,
    fireFuel: 0,
    // üí∞ ECONOMY SYSTEM
    gold: 0,
    // üå§Ô∏è WEATHER MODE
    weatherMode: 'game',
    weatherData: null,
    lastWeatherFetch: 0
  },

  seasons: [
    { 
      name: 'Jaro', 
      hungerDrain: 4, 
      waterDrain: 3,
      baseTemp: 15,
      tempVariance: 5,
      icon: 'üå±',
      desc: 'ƒåas r≈Østu a sbƒõru. V√≠c materi√°l≈Ø, m√©nƒõ j√≠dla.'
    },
    { 
      name: 'L√©to', 
      hungerDrain: 3, 
      waterDrain: 6,
      baseTemp: 26,
      tempVariance: 4,
      icon: '‚òÄÔ∏è',
      desc: 'Horko a sucho. Voda je vz√°cn√°!'
    },
    { 
      name: 'Podzim', 
      hungerDrain: 6, 
      waterDrain: 4,
      baseTemp: 10,
      tempVariance: 6,
      icon: 'üçÇ',
      desc: 'ƒåas skliznƒõ. P≈ôiprav se na zimu.'
    },
    { 
      name: 'Zima', 
      hungerDrain: 10, 
      waterDrain: 3,
      baseTemp: -5,
      tempVariance: 8,
      icon: '‚ùÑÔ∏è',
      desc: 'Drsn√° zima. P≈ôe≈æije≈° jen s dostatkem z√°sob.'
    }
  ],

  items: {
    // üí∞ ECONOMY: sellPrice = co dostanu za prodej, buyPrice = co mus√≠m zaplatit
    wood: { name: 'D≈ôevo', icon: 'üå≥', desc: 'Z√°kladn√≠ stavebn√≠ materi√°l', sellPrice: 2 },
    stone: { name: 'K√°men', icon: '‚õ∞Ô∏è', desc: 'Tvrd√Ω materi√°l pro n√°stroje', sellPrice: 3 },
    fiber: { name: 'Vl√°kna', icon: 'üåæ', desc: 'Pro v√Ωrobu provaz≈Ø', sellPrice: 1 },
    mushroom: { name: 'Houba', icon: 'üçÑ', desc: 'Jedl√° nebo nejedl√°', sellPrice: 4 },
    bark: { name: 'K≈Øra', icon: 'üü´', desc: 'Such√° k≈Øra na zap√°len√≠', sellPrice: 2 },
    stick: { name: 'H≈Øl', icon: 'ü¶Ø', desc: 'U≈æiteƒçn√° tyƒç', sellPrice: 4 },
    rope: { name: 'Provaz', icon: '‚û∞', desc: 'Pevn√© vl√°kno', sellPrice: 6 },
    trap: { name: 'Past', icon: 'üêÄ', desc: 'Chyt√° zvƒõ≈ô', sellPrice: 15 },
    basket: { name: 'Ko≈°', icon: 'üß∫', desc: 'Pro sbƒõr bobul√≠', sellPrice: 12 },
    knife: { name: 'N≈Ø≈æ', icon: 'üî™', desc: 'Z√°kladn√≠ n√°stroj pro ≈ôez√°n√≠', sellPrice: 30 },
    axe: { name: 'Sekyrka', icon: 'ü™ì', desc: 'Pro k√°cen√≠ d≈ôeva', sellPrice: 45 },
    bowl: { name: 'Miska', icon: 'ü•£', desc: 'N√°doba na vodu', sellPrice: 8 },
    leather: { name: 'K≈Ø≈æe', icon: 'ü¶∫', desc: 'Zpracovan√° k≈Ø≈æe', sellPrice: 20 },
    plank: { name: 'Prkno', icon: 'üìè', desc: 'Opracovan√© d≈ôevo', sellPrice: 5 },
    bow: { name: 'Luk', icon: 'üèπ', desc: 'Pro lov', sellPrice: 60 },
    seeds: { name: 'Semena', icon: 'üå±', desc: 'Pro pƒõstov√°n√≠ j√≠dla', sellPrice: 3 },
    food: { name: 'J√≠dlo', icon: 'üçñ', desc: 'Udr≈æuje ≈æivot', buyPrice: 5 },
    water_supply: { name: 'Voda', icon: 'üíß', desc: 'Udr≈æuje ≈æivot', buyPrice: 4 },
    storage: { name: 'Sklad', icon: 'üì¶', desc: 'Uchov√°v√° z√°soby p≈ôes zimu', sellPrice: 50 },
    insulation: { name: 'Izolace', icon: 'üß±', desc: 'Zlep≈°uje tepelnou izolaci', sellPrice: 80 },
    fireplace: { name: 'Krb', icon: 'üî•', desc: 'Vyt√°p√≠ doupƒõ', sellPrice: 100 },
    dried_meat: { name: 'Su≈°en√© maso', icon: 'ü•©', desc: 'Vydr≈æ√≠ p≈ôes zimu', sellPrice: 25 },
    wall: { name: 'D≈ôevƒõn√° hradba', icon: 'üõ°Ô∏è', desc: 'Chr√°n√≠ p≈ôed √∫toky', sellPrice: 120 },
    guard_tower: { name: 'Str√°≈æn√≠ vƒõ≈æ', icon: 'üëÅÔ∏è', desc: 'Odhal√≠ nep≈ô√°tele', sellPrice: 100 },
    medicine_hut: { name: 'L√©k√°rna', icon: 'üíä', desc: 'L√©ƒç√≠ zranƒõn√≠', sellPrice: 80 },
    
    // üìö BOOKS & KNOWLEDGE SYSTEM
    coal: { name: 'Uhl√≠', icon: '‚ö´', desc: 'Zbytky z ohnƒõ, na psan√≠', sellPrice: 6 },
    hemp: { name: 'Konop√≠', icon: 'üåø', desc: 'Surovina pro hedv√°b√≠', sellPrice: 3 },
    silk: { name: 'Hedv√°b√≠', icon: 'üßµ', desc: 'Jemn√° tkanina', sellPrice: 15 },
    press: { name: 'Lis', icon: 'üóúÔ∏è', desc: 'N√°stroj pro v√Ωrobu pap√≠ru', sellPrice: 70 },
    paper: { name: 'Pap√≠r', icon: 'üìÑ', desc: 'Z√°klad pro knihy', sellPrice: 8 },
    pencil: { name: 'Tu≈æka', icon: '‚úèÔ∏è', desc: 'Psac√≠ n√°stroj z uhl√≠', sellPrice: 10 },
    book: { name: 'Kniha', icon: 'üìï', desc: 'Uchov√°v√° znalosti', sellPrice: 60 },
    ledger: { name: '√öƒçetn√≠ kniha', icon: 'üìö', desc: '+10% gold z obchod≈Ø', sellPrice: 120 },
    
    // üõ¢Ô∏è STORAGE EXPANSION
    barrel: { name: 'Sud na vodu', icon: 'üõ¢Ô∏è', desc: '+50 kapacita vody', sellPrice: 55 },
    
    // üçñ COOKING SYSTEM
    berries: { name: 'Bobule', icon: 'üçí', desc: 'ƒåerstv√© lesn√≠ bobule', sellPrice: 2 },
    fish: { name: 'Ryba', icon: 'üêü', desc: 'ƒåerstv√° ryba', sellPrice: 6 },
    cooked_meat: { name: 'Uva≈ôen√© maso', icon: 'üçñ', desc: '+15 hunger (vs +10 raw)', sellPrice: 15 },
    fish_stew: { name: 'Ryb√≠ pol√©vka', icon: 'üç≤', desc: '+20 hunger +5 water', sellPrice: 20 },
    berry_jam: { name: 'D≈æem z bobul√≠', icon: 'ü•´', desc: '+8 hunger, dlouh√° ≈æivotnost', sellPrice: 12 },
    },

  recipes: [
    // Tier 1 - Z√°klady
    {
      id: 'stick',
      name: 'H≈Øl',
      icon: 'ü¶Ø',
      materials: { wood: 1 },
      result: { stick: 2 },
      tier: 1
    },
    {
      id: 'rope',
      name: 'Provaz',
      icon: '‚û∞',
      materials: { fiber: 3 },
      result: { rope: 1 },
      tier: 1
    },
    {
      id: 'bowl',
      name: 'Miska',
      icon: 'ü•£',
      materials: { wood: 2 },
      result: { bowl: 1 },
      tier: 1
    },
    {
      id: 'trap',
      name: 'Past na zvƒõ≈ô',
      icon: 'üêÄ',
      materials: { rope: 2, stick: 3 },
      result: { trap: 1 },
      tier: 1,
      desc: 'Chyt√° malou zvƒõ≈ô p≈ôes noc'
    },
    {
      id: 'basket',
      name: 'Sbƒõrac√≠ ko≈°',
      icon: 'üß∫',
      materials: { fiber: 5, stick: 2 },
      result: { basket: 1 },
      tier: 1,
      desc: 'Pro sbƒõr bobul√≠ a hub'
    },
    
    // Tier 2 - Z√°kladn√≠ n√°stroje
    {
      id: 'knife',
      name: 'Kamenn√Ω n≈Ø≈æ',
      icon: 'üî™',
      materials: { stone: 2, stick: 1 },
      result: { knife: 1 },
      tier: 2,
      unlock: 'first_entity'
    },
    {
      id: 'axe',
      name: 'Sekyrka',
      icon: 'ü™ì',
      materials: { stone: 3, stick: 2, rope: 1 },
      result: { axe: 1 },
      tier: 2,
      unlock: 'first_entity'
    },
    // üî• FIRE SYSTEM - Bow Drill (Tier 2)
    {
      id: 'start_fire_drill',
      name: 'Zalo≈æit ohe≈à (Bow Drill)',
      icon: 'üî•',
      materials: { stick: 2, fiber: 3, bark: 1 },
      requires: { bow: 1 },
      tier: 2,
      desc: '80% ≈°ance na √∫spƒõch',
      isFireStarter: true,
      fireChance: 0.8,
      fireMethod: 'bow_drill'
    },

    // Tier 3 - Pokroƒçil√©
    {
      id: 'plank',
      name: 'Prkno',
      icon: 'üìè',
      materials: { wood: 2 },
      result: { plank: 1 },
      requires: { axe: 1 },
      tier: 3
    },
    {
      id: 'leather',
      name: 'K≈Ø≈æe',
      icon: 'ü¶∫',
      materials: { food: 2 },
      result: { leather: 1 },
      requires: { knife: 1 },
      tier: 3
    },
    {
      id: 'bow',
      name: 'Luk',
      icon: 'üèπ',
      materials: { stick: 3, rope: 2 },
      result: { bow: 1 },
      tier: 3,
      unlock: 'hunter_entity'
    },
    // üî• FIRE SYSTEM - K≈ôesadlo (Tier 3)
    {
      id: 'start_fire_flint',
      name: 'Zalo≈æit ohe≈à (K≈ôesadlo)',
      icon: '‚ö°',
      materials: { stone: 3 },
      requires: { knife: 1 },
      tier: 3,
      desc: '100% √∫spƒõch',
      isFireStarter: true,
      fireChance: 0.8,
      fireMethod: 'flint_steel'
    },
    
    // üî• FIRE-BASED CRAFTING
    {
      id: 'dried_meat',
      name: 'Su≈°en√© maso',
      icon: 'ü•©',
      materials: { food: 5 },
      requiresFire: true,
      result: { dried_meat: 3 },
      tier: 3,
      desc: 'Vydr≈æ√≠ p≈ôes zimu, neskaz√≠ se'
    },
    
    // üìö BOOKS & KNOWLEDGE SYSTEM (Tier 3-4)
    {
      id: 'hemp',
      name: 'Konop√≠',
      icon: 'üåø',
      materials: { fiber: 5, water_supply: 2 },
      result: { hemp: 3 },
      tier: 3,
      desc: 'Zpracovan√© vl√°kna'
    },
    {
      id: 'silk',
      name: 'Hedv√°b√≠',
      icon: 'üßµ',
      materials: { hemp: 4, fiber: 8 },
      result: { silk: 2 },
      tier: 3,
      desc: 'Jemn√° tkanina pro pap√≠r'
    },
    {
      id: 'press',
      name: 'Lis',
      icon: 'üóúÔ∏è',
      materials: { plank: 6, stone: 4, rope: 3 },
      requires: { axe: 1 },
      result: { press: 1 },
      tier: 3,
      desc: 'Pokroƒçil√Ω n√°stroj pro v√Ωrobu pap√≠ru'
    },
    {
      id: 'paper',
      name: 'Pap√≠r',
      icon: 'üìÑ',
      materials: { silk: 2, hemp: 3, bark: 2, water_supply: 5 },
      requires: { press: 1 },
      result: { paper: 5 },
      tier: 3,
      desc: 'Z√°klad pro knihy'
    },
    {
      id: 'pencil',
      name: 'Tu≈æka',
      icon: '‚úèÔ∏è',
      materials: { coal: 2, stick: 1 },
      result: { pencil: 1 },
      tier: 3,
      desc: 'Psac√≠ n√°stroj (uhl√≠ z ohnƒõ)'
    },
    {
      id: 'book',
      name: 'Kniha',
      icon: 'üìï',
      materials: { paper: 10, leather: 2, rope: 1 },
      requires: { pencil: 1 },
      result: { book: 1 },
      tier: 4,
      desc: 'Uchov√°v√° znalosti kolonie'
    },
    {
      id: 'ledger',
      name: '√öƒçetn√≠ kniha',
      icon: 'üìö',
      materials: { book: 1, paper: 5 },
      result: { ledger: 1 },
      tier: 4,
      unlock: 'accounting_bonus',
      desc: '+10% gold ze v≈°ech obchod≈Ø'
    },
    
    // üçñ COOKING SYSTEM (Tier 2-3)
    {
      id: 'cooked_meat',
      name: 'Uva≈ôen√© maso',
      icon: 'üçñ',
      materials: { food: 2 },
      requiresFire: true,
      result: { cooked_meat: 1 },
      tier: 2,
      desc: '+15 hunger (raw m√° jen +10)'
    },
    {
      id: 'fish_stew',
      name: 'Ryb√≠ pol√©vka',
      icon: 'üç≤',
      materials: { fish: 2, water_supply: 3, mushroom: 1 },
      requiresFire: true,
      result: { fish_stew: 1 },
      tier: 2,
      desc: '+20 hunger, +5 water'
    },
    {
      id: 'berry_jam',
      name: 'D≈æem z bobul√≠',
      icon: 'ü•´',
      materials: { berries: 5 },
      requiresFire: true,
      result: { berry_jam: 2 },
      tier: 2,
      desc: '+8 hunger, neplesnivƒõj√≠'
    },
    
    // Tier 4 - Infrastruktura
    {
      id: 'storage',
      name: 'Sklad na zimu',
      icon: 'üì¶',
      materials: { plank: 5, rope: 3 },
      result: { storage: 1 },
      tier: 4
    },
    {
      id: 'barrel',
      name: 'Sud na vodu',
      icon: 'üõ¢Ô∏è',
      materials: { plank: 8, rope: 3 },
      result: { barrel: 1 },
      tier: 4,
      desc: '+50 kapacita vody'
    },
    {
      id: 'fireplace',
      name: 'Krb',
      icon: 'üî•',
      materials: { stone: 8, plank: 3 },
      result: { fireplace: 1 },
      tier: 4,
      desc: 'Umo≈æ≈àuje topit d≈ôevem'
    },
    {
      id: 'insulation',
      name: 'Tepeln√° izolace',
      icon: 'üß±',
      materials: { fiber: 10, plank: 5, leather: 2 },
      result: { insulation: 1 },
      tier: 4,
      desc: 'Zlep≈°uje izolaci doupƒõte'
    },
    {
      id: 'wall',
      name: 'D≈ôevƒõn√° hradba',
      icon: 'üõ°Ô∏è',
      materials: { plank: 10, stone: 5, rope: 3 },
      result: { wall: 1 },
      tier: 4,
      desc: 'Chr√°n√≠ kolonii p≈ôed √∫toky'
    },
    {
      id: 'guard_tower',
      name: 'Str√°≈æn√≠ vƒõ≈æ',
      icon: 'üëÅÔ∏è',
      materials: { plank: 8, rope: 4 },
      requires: { bow: 1 },
      result: { guard_tower: 1 },
      tier: 4,
      desc: 'Odhal√≠ nep≈ô√°tele na d√°lku'
    },
    {
      id: 'medicine_hut',
      name: 'L√©k√°rna',
      icon: 'üíä',
      materials: { plank: 6, fiber: 12, mushroom: 5 },
      result: { medicine_hut: 1 },
      tier: 4,
      desc: 'L√©ƒç√≠ nemoci a zranƒõn√≠'
    }
  ],

  // Ud√°losti co m≈Ø≈æou nastat ka≈æd√Ω den
  randomEvents: [
    {
      id: 'wood_fall',
      chance: 0.4,
      items: { wood: [2, 4] },
      message: 'üå≥ Nƒõkolik vƒõtv√≠ spadlo ze stropu'
    },
    {
      id: 'stone_fall',
      chance: 0.3,
      items: { stone: [1, 3] },
      message: '‚õ∞Ô∏è Kameny se uvolnily ze stƒõny'
    },
    {
      id: 'fiber_find',
      chance: 0.35,
      items: { fiber: [3, 5] },
      message: 'üåæ Na≈°el jsi svazky vl√°ken'
    },
    {
      id: 'bark_find', // üî• NEW EVENT
      chance: 0.35,
      items: { bark: [2, 6] },
      message: 'üü´ K≈Øra spadla ze stromu'
    },
    {
      id: 'water_drip',
      chance: 0.8,
      items: { water_supply: [6, 12] },
      message: 'üíß Voda kape ze stropu do misek'
    },
    {
      id: 'mushroom_find',
      chance: 0.65,
      items: { food: [2, 4] },
      message: 'üçÑ Na≈°el jsi jedl√© houby'
    },
    {
      id: 'seed_find',
      chance: 0.3,
      season: [0], // pouze na ja≈ôe
      items: { seeds: [2, 4] },
      message: 'üå± V√≠tr p≈ôinesl semena'
    },
    {
      id: 'nothing',
      chance: 0.15,
      message: '...ticho a pr√°zdnota...'
    }
  ],

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üó°Ô∏è ATTACK SYSTEM - PART 1: Attack Events & Defense Items

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üó°Ô∏è THREATS SYSTEM - Universal Combat Configuration
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  threats: {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üè¥‚Äç‚ò†Ô∏è TIER 3: N√°jezdn√≠ci (tƒõ≈æk√©)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    bandits: {
      id: 'bandits',
      name: 'N√°jezd bandit≈Ø',
      icon: 'üè¥‚Äç‚ò†Ô∏è',
      tier: 3,
      seasons: [2, 3], // podzim, zima
      
      intro: 'Banditi objevili doupƒõ! Chtƒõj√≠ tvoje zlato a z√°soby.',
      
      playerIcon: 'üèπ',
      enemyIcon: 'üó°Ô∏è',
      aiDifficulty: 'hard',
      boardSize: 8,
      
      onDefeat: {
        gold: -0.5, // 50% zlata
        items: { 
          food: [-30, -50],
          water_supply: [-20, -30] 
        },
        casualties: 0.3, // 30% ≈°ance na smrt entity
        message: 'üè¥‚Äç‚ò†Ô∏è Banditi ukradli z√°soby a zlato!'
      },
      onVictory: {
        gold: [50, 100],
        items: { leather: [3, 6] },
        message: 'üèπ Banditi pora≈æeni! Zabavuje≈° jejich v√Ωbavu.'
      }
    },
  
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üê∫ TIER 3: Vlci (tƒõ≈æk√©, zvl√°≈°tƒõ v zimƒõ)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    wolves: {
      id: 'wolves',
      name: '√ötok vlƒç√≠ smeƒçky',
      icon: 'üê∫',
      tier: 3,
      seasons: [2, 3], // podzim, zima (hladov√≠)
      
      intro: 'Hladov√° smeƒçka vlk≈Ø vnikla do doupƒõte!',
      
      playerIcon: 'üî•',
      enemyIcon: 'üê∫',
      aiDifficulty: 'hard',
      boardSize: 7,
      
      onDefeat: {
        items: { 
          food: [-40, -60],
        },
        casualties: 0.4, // 40% ≈°ance
        message: 'üê∫ Vlci zabili obyvatele a ukradli j√≠dlo!'
      },
      onVictory: {
        items: { 
          leather: [5, 10],
          food: [20, 30]
        },
        message: 'üî• Vlci pora≈æeni! Z√≠sk√°v√°≈° k≈Ø≈æe a maso.'
      }
    },
  
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üêÄ TIER 2: Krysy (st≈ôedn√≠)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    rats: {
      id: 'rats',
      name: 'Zamo≈ôen√≠ krysami',
      icon: 'üêÄ',
      tier: 2,
      seasons: [0, 1, 2], // ne v zimƒõ
      
      intro: 'Horda krys se val√≠ z tunel≈Ø! √ötoƒç√≠ na z√°soby.',
      
      playerIcon: 'ü™§',
      enemyIcon: 'üêÄ',
      aiDifficulty: 'medium',
      boardSize: 6,
      
      onDefeat: {
        items: { 
          food: [-30, -50],
          water_supply: [-20, -30] 
        },
        casualties: 0.2,
        message: 'üêÄ Krysy zniƒçily z√°soby!'
      },
      onVictory: {
        items: { 
          leather: [2, 5],
          food: [10, 20]
        },
        message: 'ü™§ Krysy pora≈æeny! Z√≠sk√°v√°≈° k≈Ø≈æe.'
      }
    },
  
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ü¶ü TIER 1: Hmyz (lehk√©, obt√≠≈æn√©)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    bugs: {
      id: 'bugs',
      name: 'Invaze hmyzu',
      icon: 'ü™≤',
      tier: 1,
      seasons: [0, 1], // jaro, l√©to
      
      intro: '≈†tƒõnice a ≈°v√°bi se roj√≠ v doupƒõti! Obyvatel√© nemohou sp√°t.',
      
      playerIcon: 'üí®',
      enemyIcon: 'ü¶ü',
      aiDifficulty: 'easy',
      boardSize: 5,
      
      onDefeat: {
        items: { 
          food: [-10, -20],
        },
        casualties: 0.1,
        message: 'ü™≤ Hmyz zniƒçil ƒç√°st z√°sob!'
      },
      onVictory: {
        items: { 
          food: [5, 10] // sp√°len√Ω hmyz = protein
        },
        message: 'üí® Hmyz vykou≈ôen! Obyvatel√© mohou sp√°t.'
      }
    },
  
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üíÄ TIER 4: Mor (kritick√©, kdykoliv)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    plague: {
      id: 'plague',
      name: 'Epidemie moru',
      icon: 'üíÄ',
      tier: 4,
      seasons: null, // kdykoliv
      
      intro: 'Z√°hadn√° nemoc se ≈°√≠≈ô√≠ koloni√≠! Lid√© um√≠raj√≠.',
      
      playerIcon: 'üíä',
      enemyIcon: 'ü¶†',
      aiDifficulty: 'medium',
      boardSize: 8,
      
      // M≈Ø≈æe≈° skipnout pokud m√°≈° medicine_hut
      canAvoid: { medicine_hut: 1 },
      avoidMessage: 'üíä L√©k√°rna zachr√°nila kolonii od epidemie!',
      
      onDefeat: {
        casualties: 0.5, // 50% ≈°ance!
        items: {
          food: [-20, -30]
        },
        message: 'üíÄ Mor zabil ƒç√°st kolonie!'
      },
      onVictory: {
        message: 'üíä Nemoc zastavena! Kolonie p≈ôe≈æila.'
      }
    }
  },
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéÆ COMBAT SYSTEM - Pi≈°kvorky 8x8
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  combat: {
    board: null,
    size: 8,
    currentThreat: null,
    playerIcon: 'üèπ',
    enemyIcon: 'üó°Ô∏è',
    gameActive: false,
    gameType: 'tictactoe', // 'tictactoe', 'go', 'dnd'
    
    // D&D-specific properties
    playerHP: 0,
    playerMaxHP: 0,
    enemyHP: 0,
    enemyMaxHP: 0,
    playerAttack: 5,
    playerDefense: 3,
    enemyAttack: 3,
    enemyDefense: 2,
    combatLog: [],
    
    // Go-specific properties
    capturedStones: { player: 0, enemy: 0 },
    maxTurns: 30,
    currentTurn: 0,
    passCount: 0,
    lastMove: null,
    
    init(threat, gameType = 'tictactoe') {
      this.currentThreat = threat;
      this.gameType = gameType;
      this.size = threat.boardSize || 8;
      this.playerIcon = threat.playerIcon;
      this.enemyIcon = threat.enemyIcon;
      this.board = Array(this.size).fill(null).map(() => Array(this.size).fill(null));
      this.gameActive = true;
      this.combatLog = [];
      
      // Init D&D if needed
      if (gameType === 'dnd') {
        this.initDnD(threat);
      }
      
      // Init Go if needed
      if (gameType === 'go') {
        this.initGo(threat);
      }
    },
    
    initGo(threat) {
      this.capturedStones = { player: 0, enemy: 0 };
      this.currentTurn = 0;
      this.passCount = 0;
      this.lastMove = null;
      
      // Max turns based on difficulty
      const turnMap = {
        easy: 20,
        medium: 30,
        hard: 40,
        expert: 50
      };
      this.maxTurns = turnMap[threat.aiDifficulty] || 30;
      
      this.combatLog.push(`‚ö´‚ö™ Hra Go zaƒç√≠n√°! Max tah≈Ø: ${this.maxTurns}`);
    },
    
    initDnD(threat) {
      // Calculate player HP from food (but DON'T consume it!)
      const food = game.state.inventory.food || 0;
      this.playerMaxHP = Math.max(20, food * 5); // Min 20 HP
      this.playerHP = this.playerMaxHP;
      
      // Enemy HP based on difficulty
      const hpMap = {
        easy: 30,
        medium: 50,
        hard: 70,
        expert: 100
      };
      this.enemyMaxHP = hpMap[threat.aiDifficulty] || 50;
      this.enemyHP = this.enemyMaxHP;
      
      // Adjust enemy stats based on difficulty
      const statsMap = {
        easy: { attack: 2, defense: 1 },
        medium: { attack: 3, defense: 2 },
        hard: { attack: 4, defense: 3 },
        expert: { attack: 5, defense: 4 }
      };
      const stats = statsMap[threat.aiDifficulty] || { attack: 3, defense: 2 };
      this.enemyAttack = stats.attack;
      this.enemyDefense = stats.defense;
      
      this.combatLog.push(`‚öîÔ∏è Boj zaƒç√≠n√°! Tvoje HP: ${this.playerHP}/${this.playerMaxHP} | ${threat.name} HP: ${this.enemyHP}/${this.enemyMaxHP}`);
    },
    
    makeMove(row, col) {
      if (!this.gameActive || this.board[row][col]) return false;
      
      this.board[row][col] = 'player';
      
      // Check win
      if (this.checkWin('player')) {
        this.gameActive = false;
        return 'player_win';
      }
      
      // üéØ Check if game is dead (no one can win anymore)
      if (!this.canAnyoneWin()) {
        this.gameActive = false;
        return 'draw';
      }
      
      // Check draw (board full)
      if (this.isBoardFull()) {
        this.gameActive = false;
        return 'draw';
      }
      
      // AI move
      setTimeout(() => {
        this.aiMove();
        
        if (this.checkWin('enemy')) {
          this.gameActive = false;
          game.handleCombatEnd(false);
        } else if (!this.canAnyoneWin()) {
          // üéØ Check dead game after AI move
          this.gameActive = false;
          game.handleCombatEnd(true); // draw = player win (no penalty)
        } else if (this.isBoardFull()) {
          this.gameActive = false;
          game.handleCombatEnd(true); // draw = player win
        }
      }, 500);
      
      return true;
    },
    
    aiMove() {
      const difficulty = this.currentThreat.aiDifficulty;
      let move = null;
      
      switch(difficulty) {
        case 'easy':
          move = this.findRandomMove();
          break;
        case 'medium':
          move = this.findBlockingMove() || this.findWinningMove() || this.findRandomMove();
          break;
        case 'hard':
          move = this.findWinningMove() || this.findBlockingMove() || this.findStrategicMove();
          break;
        case 'expert':
          move = this.findBestMove();
          break;
      }
      
      if (move) {
        this.board[move.row][move.col] = 'enemy';
        game.renderCombatBoard();
      }
    },
    
    findWinningMove() {
      // Find move that wins for AI
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (!this.board[r][c]) {
            this.board[r][c] = 'enemy';
            if (this.checkWin('enemy')) {
              this.board[r][c] = null;
              return { row: r, col: c };
            }
            this.board[r][c] = null;
          }
        }
      }
      return null;
    },
    
    findBlockingMove() {
      // Find move that blocks player from winning
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (!this.board[r][c]) {
            this.board[r][c] = 'player';
            if (this.checkWin('player')) {
              this.board[r][c] = null;
              return { row: r, col: c };
            }
            this.board[r][c] = null;
          }
        }
      }
      return null;
    },
    
    findStrategicMove() {
      // Prefer center, then adjacent to existing pieces
      const center = Math.floor(this.size / 2);
      
      // Try center
      if (!this.board[center][center]) {
        return { row: center, col: center };
      }
      
      // Try near existing pieces
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] && this.hasEmptyNeighbor(r, c)) {
            const empty = this.getEmptyNeighbor(r, c);
            if (empty) return empty;
          }
        }
      }
      
      return this.findRandomMove();
    },
    
    findRandomMove() {
      const empty = [];
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (!this.board[r][c]) empty.push({ row: r, col: c });
        }
      }
      return empty.length > 0 ? empty[Math.floor(Math.random() * empty.length)] : null;
    },
    
    findBestMove() {
      // Expert AI - look ahead 2 moves
      let bestScore = -Infinity;
      let bestMove = null;
      
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (!this.board[r][c]) {
            this.board[r][c] = 'enemy';
            const score = this.minimax(1, false, -Infinity, Infinity);
            this.board[r][c] = null;
            
            if (score > bestScore) {
              bestScore = score;
              bestMove = { row: r, col: c };
            }
          }
        }
      }
      
      return bestMove || this.findRandomMove();
    },
    
    minimax(depth, isMaximizing, alpha, beta) {
      if (this.checkWin('enemy')) return 10 - depth;
      if (this.checkWin('player')) return depth - 10;
      if (this.isBoardFull() || depth > 2) return 0;
      
      if (isMaximizing) {
        let maxScore = -Infinity;
        for (let r = 0; r < this.size; r++) {
          for (let c = 0; c < this.size; c++) {
            if (!this.board[r][c]) {
              this.board[r][c] = 'enemy';
              const score = this.minimax(depth + 1, false, alpha, beta);
              this.board[r][c] = null;
              maxScore = Math.max(score, maxScore);
              alpha = Math.max(alpha, score);
              if (beta <= alpha) break;
            }
          }
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (let r = 0; r < this.size; r++) {
          for (let c = 0; c < this.size; c++) {
            if (!this.board[r][c]) {
              this.board[r][c] = 'player';
              const score = this.minimax(depth + 1, true, alpha, beta);
              this.board[r][c] = null;
              minScore = Math.min(score, minScore);
              beta = Math.min(beta, score);
              if (beta <= alpha) break;
            }
          }
        }
        return minScore;
      }
    },
    
    hasEmptyNeighbor(r, c) {
      const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
      return dirs.some(([dr,dc]) => {
        const nr = r + dr, nc = c + dc;
        return nr >= 0 && nr < this.size && nc >= 0 && nc < this.size && !this.board[nr][nc];
      });
    },
    
    getEmptyNeighbor(r, c) {
      const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
      for (const [dr, dc] of dirs) {
        const nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size && !this.board[nr][nc]) {
          return { row: nr, col: nc };
        }
      }
      return null;
    },
    
    checkWin(player) {
      // Check 5 in a row (horizontal, vertical, diagonal)
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === player) {
            // Check all 4 directions
            if (this.checkDirection(r, c, 0, 1, player) || // horizontal
                this.checkDirection(r, c, 1, 0, player) || // vertical
                this.checkDirection(r, c, 1, 1, player) || // diagonal \
                this.checkDirection(r, c, 1, -1, player)) { // diagonal /
              return true;
            }
          }
        }
      }
      return false;
    },
    
    checkDirection(r, c, dr, dc, player) {
      let count = 0;
      for (let i = 0; i < 5; i++) {
        const nr = r + i * dr;
        const nc = c + i * dc;
        if (nr < 0 || nr >= this.size || nc < 0 || nc >= this.size || this.board[nr][nc] !== player) {
          return false;
        }
        count++;
      }
      return count === 5;
    },
    
    isBoardFull() {
      return this.board.every(row => row.every(cell => cell !== null));
    },
    
    // üéØ Check if anyone can still win (make 5 in a row)
    canAnyoneWin() {
      // For each position, check if it can be part of a winning sequence
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          // Check all 4 directions from this position
          const directions = [
            [0, 1],   // horizontal ‚Üí
            [1, 0],   // vertical ‚Üì
            [1, 1],   // diagonal ‚Üò
            [1, -1]   // diagonal ‚Üô
          ];
          
          for (const [dr, dc] of directions) {
            // Check if a 5-sequence is possible in this direction
            if (this.canMakeFiveInDirection(r, c, dr, dc)) {
              return true; // Found at least one possible winning sequence
            }
          }
        }
      }
      return false; // No possible winning sequences left ‚Üí DRAW
    },
    
    canMakeFiveInDirection(startR, startC, dr, dc) {
      // Check if 5 cells in this direction can form a winning line
      let playerCount = 0;
      let enemyCount = 0;
      let nullCount = 0;
      
      for (let i = 0; i < 5; i++) {
        const r = startR + i * dr;
        const c = startC + i * dc;
        
        // Out of bounds ‚Üí this sequence is impossible
        if (r < 0 || r >= this.size || c < 0 || c >= this.size) {
          return false;
        }
        
        const cell = this.board[r][c];
        if (cell === 'player') playerCount++;
        else if (cell === 'enemy') enemyCount++;
        else nullCount++;
      }
      
      // A valid winning sequence has:
      // - All 5 cells are: null, player, or mix of player+null (enemy can't win here)
      // - All 5 cells are: null, enemy, or mix of enemy+null (player can't win here)
      // - All 5 cells are: null (either can win)
      
      // If both players have pieces in this sequence ‚Üí impossible
      if (playerCount > 0 && enemyCount > 0) {
        return false;
      }
      
      // Otherwise, at least one player can still complete this sequence
      return true;
    },
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé≤ D&D COMBAT ROLLS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    playerAttackRoll() {
      if (!this.gameActive || this.gameType !== 'dnd') return null;
      
      // Roll d20 + attack modifier
      const roll = Math.floor(Math.random() * 20) + 1;
      const total = roll + this.playerAttack;
      
      // Enemy defense roll
      const enemyRoll = Math.floor(Math.random() * 20) + 1;
      const enemyTotal = enemyRoll + this.enemyDefense;
      
      let result = { playerRoll: roll, playerTotal: total, enemyRoll, enemyTotal, hit: false, damage: 0, critical: false };
      
      // Critical hit (natural 20)
      if (roll === 20) {
        const damage = Math.floor(Math.random() * 10) + 10; // 10-20 damage on crit
        this.enemyHP = Math.max(0, this.enemyHP - damage);
        result.hit = true;
        result.damage = damage;
        result.critical = true;
        this.combatLog.push(`üéØ KRITICK√ù Z√ÅSAH! Hodil jsi 20! ‚Üí ${damage} damage na nep≈ô√≠tele!`);
      }
      // Hit
      else if (total > enemyTotal) {
        const damage = Math.floor(Math.random() * 10) + 5; // 5-15 damage
        this.enemyHP = Math.max(0, this.enemyHP - damage);
        result.hit = true;
        result.damage = damage;
        this.combatLog.push(`‚öîÔ∏è Z√°sah! Tv≈Øj √∫tok ${total} vs obrana ${enemyTotal} ‚Üí ${damage} damage`);
      }
      // Miss
      else {
        this.combatLog.push(`‚ùå Minut√≠! Tv≈Øj √∫tok ${total} vs obrana ${enemyTotal}`);
      }
      
      return result;
    },
    
    enemyAttackRoll() {
      if (!this.gameActive || this.gameType !== 'dnd') return null;
      
      // Enemy roll d20 + attack modifier
      const roll = Math.floor(Math.random() * 20) + 1;
      const total = roll + this.enemyAttack;
      
      // Player defense roll
      const playerRoll = Math.floor(Math.random() * 20) + 1;
      const playerTotal = playerRoll + this.playerDefense;
      
      let result = { enemyRoll: roll, enemyTotal: total, playerRoll, playerTotal, hit: false, damage: 0, critical: false };
      
      // Critical hit (natural 20)
      if (roll === 20) {
        const damage = Math.floor(Math.random() * 8) + 8; // 8-16 damage on crit
        this.playerHP = Math.max(0, this.playerHP - damage);
        result.hit = true;
        result.damage = damage;
        result.critical = true;
        this.combatLog.push(`üí• Nep≈ô√≠tel KRITICKY zas√°hl! Hodil 20! ‚Üí ${damage} damage na tebe!`);
      }
      // Hit
      else if (total > playerTotal) {
        const damage = Math.floor(Math.random() * 8) + 3; // 3-11 damage
        this.playerHP = Math.max(0, this.playerHP - damage);
        result.hit = true;
        result.damage = damage;
        this.combatLog.push(`üó°Ô∏è Nep≈ô√≠tel zas√°hl! √ötok ${total} vs tvoje obrana ${playerTotal} ‚Üí ${damage} damage`);
      }
      // Miss
      else {
        this.combatLog.push(`üõ°Ô∏è Blokov√°no! √ötok nep≈ô√≠tele ${total} vs tvoje obrana ${playerTotal}`);
      }
      
      return result;
    },
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚ö´‚ö™ GO GAME MECHANICS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    makeMove_Go(row, col, player = 'player') {
      if (!this.gameActive || this.board[row][col]) return false;
      
      // Place stone
      this.board[row][col] = player;
      this.lastMove = { row, col, player };
      this.currentTurn++;
      
      // Check captures (remove enemy stones with 0 liberties)
      const enemy = player === 'player' ? 'enemy' : 'player';
      const captured = this.captureStones(enemy);
      
      if (captured > 0) {
        this.capturedStones[player] += captured;
        this.combatLog.push(`${player === 'player' ? '‚ö™' : '‚ö´'} Zajato ${captured} kamen≈Ø!`);
      }
      
      // Check if game should end
      if (this.currentTurn >= this.maxTurns) {
        this.gameActive = false;
        return 'end';
      }
      
      return true;
    },
    
    pass() {
      this.passCount++;
      this.combatLog.push(`Pas...`);
      
      // If both players pass ‚Üí end game
      if (this.passCount >= 2) {
        this.gameActive = false;
        return 'end';
      }
      
      return true;
    },
    
    captureStones(player) {
      let captured = 0;
      const visited = Array(this.size).fill(null).map(() => Array(this.size).fill(false));
      
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === player && !visited[r][c]) {
            const group = this.getGroup(r, c, player, visited);
            const liberties = this.countLiberties(group);
            
            // If group has 0 liberties ‚Üí capture
            if (liberties === 0) {
              group.forEach(({r, c}) => {
                this.board[r][c] = null;
                captured++;
              });
            }
          }
        }
      }
      
      return captured;
    },
    
    getGroup(startR, startC, player, visited) {
      const group = [];
      const stack = [{r: startR, c: startC}];
      
      while (stack.length > 0) {
        const {r, c} = stack.pop();
        
        if (r < 0 || r >= this.size || c < 0 || c >= this.size) continue;
        if (visited[r][c]) continue;
        if (this.board[r][c] !== player) continue;
        
        visited[r][c] = true;
        group.push({r, c});
        
        // Add neighbors to stack
        stack.push({r: r-1, c});
        stack.push({r: r+1, c});
        stack.push({r, c: c-1});
        stack.push({r, c: c+1});
      }
      
      return group;
    },
    
    countLiberties(group) {
      const liberties = new Set();
      
      group.forEach(({r, c}) => {
        // Check 4 neighbors
        const neighbors = [
          {r: r-1, c},
          {r: r+1, c},
          {r, c: c-1},
          {r, c: c+1}
        ];
        
        neighbors.forEach(({r: nr, c: nc}) => {
          if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
            if (this.board[nr][nc] === null) {
              liberties.add(`${nr},${nc}`);
            }
          }
        });
      });
      
      return liberties.size;
    },
    
    calculateGoWinner() {
      // Count territory for each player
      const playerTerritory = this.countTerritory('player');
      const enemyTerritory = this.countTerritory('enemy');
      
      // Add captured stones to score
      const playerScore = playerTerritory + this.capturedStones.enemy;
      const enemyScore = enemyTerritory + this.capturedStones.player;
      
      this.combatLog.push(`‚ö™ Tvoje sk√≥re: ${playerScore} (√∫zem√≠: ${playerTerritory} + zajato: ${this.capturedStones.enemy})`);
      this.combatLog.push(`‚ö´ Nep≈ô√≠tel: ${enemyScore} (√∫zem√≠: ${enemyTerritory} + zajato: ${this.capturedStones.player})`);
      
      return playerScore > enemyScore ? 'player_win' : 'enemy_win';
    },
    
    countTerritory(player) {
      const visited = Array(this.size).fill(null).map(() => Array(this.size).fill(false));
      let territory = 0;
      
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === null && !visited[r][c]) {
            const empty = this.getEmptyRegion(r, c, visited);
            const borders = this.getRegionBorders(empty);
            
            // If region borders only one player ‚Üí that player's territory
            if (borders.player && !borders.enemy) {
              territory += empty.length;
            } else if (borders.enemy && !borders.player) {
              // Enemy territory (count for enemy)
            }
            // else: disputed territory (no one gets points)
          }
        }
      }
      
      return territory;
    },
    
    getEmptyRegion(startR, startC, visited) {
      const region = [];
      const stack = [{r: startR, c: startC}];
      
      while (stack.length > 0) {
        const {r, c} = stack.pop();
        
        if (r < 0 || r >= this.size || c < 0 || c >= this.size) continue;
        if (visited[r][c]) continue;
        if (this.board[r][c] !== null) continue;
        
        visited[r][c] = true;
        region.push({r, c});
        
        stack.push({r: r-1, c});
        stack.push({r: r+1, c});
        stack.push({r, c: c-1});
        stack.push({r, c: c+1});
      }
      
      return region;
    },
    
    getRegionBorders(region) {
      const borders = { player: false, enemy: false };
      
      region.forEach(({r, c}) => {
        const neighbors = [
          {r: r-1, c},
          {r: r+1, c},
          {r, c: c-1},
          {r, c: c+1}
        ];
        
        neighbors.forEach(({r: nr, c: nc}) => {
          if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
            if (this.board[nr][nc] === 'player') borders.player = true;
            if (this.board[nr][nc] === 'enemy') borders.enemy = true;
          }
        });
      });
      
      return borders;
    },
    
    // Simple AI for Go
    findGoMove() {
      const difficulty = this.currentThreat.aiDifficulty;
      
      // Easy: Random empty cell
      if (difficulty === 'easy') {
        return this.findRandomEmptyCell();
      }
      
      // Medium/Hard: Try to capture or defend
      if (difficulty === 'medium' || difficulty === 'hard') {
        // Try to capture enemy stones
        const captureMove = this.findCaptureMove();
        if (captureMove) return captureMove;
        
        // Try to save own stones
        const saveMove = this.findSaveMove();
        if (saveMove) return saveMove;
        
        // Fall back to random
        return this.findRandomEmptyCell();
      }
      
      // Expert: Territory control
      if (difficulty === 'expert') {
        const captureMove = this.findCaptureMove();
        if (captureMove) return captureMove;
        
        const saveMove = this.findSaveMove();
        if (saveMove) return saveMove;
        
        const territoryMove = this.findTerritoryMove();
        if (territoryMove) return territoryMove;
        
        return this.findRandomEmptyCell();
      }
      
      return this.findRandomEmptyCell();
    },
    
    findRandomEmptyCell() {
      const empty = [];
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === null) {
            empty.push({r, c});
          }
        }
      }
      return empty.length > 0 ? empty[Math.floor(Math.random() * empty.length)] : null;
    },
    
    findCaptureMove() {
      // Find enemy group with 1 liberty
      const visited = Array(this.size).fill(null).map(() => Array(this.size).fill(false));
      
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === 'player' && !visited[r][c]) {
            const group = this.getGroup(r, c, 'player', visited);
            const liberties = this.getLibertyPositions(group);
            
            if (liberties.length === 1) {
              return liberties[0]; // Capture move!
            }
          }
        }
      }
      
      return null;
    },
    
    findSaveMove() {
      // Find own group with 1 liberty
      const visited = Array(this.size).fill(null).map(() => Array(this.size).fill(false));
      
      for (let r = 0; r < this.size; r++) {
        for (let c = 0; c < this.size; c++) {
          if (this.board[r][c] === 'enemy' && !visited[r][c]) {
            const group = this.getGroup(r, c, 'enemy', visited);
            const liberties = this.getLibertyPositions(group);
            
            if (liberties.length === 1) {
              return liberties[0]; // Save move!
            }
          }
        }
      }
      
      return null;
    },
    
    findTerritoryMove() {
      // Prefer corners and edges
      const corners = [
        {r: 0, c: 0}, {r: 0, c: this.size-1},
        {r: this.size-1, c: 0}, {r: this.size-1, c: this.size-1}
      ];
      
      for (const pos of corners) {
        if (this.board[pos.r][pos.c] === null) return pos;
      }
      
      // Edges
      const edges = [];
      for (let i = 0; i < this.size; i++) {
        edges.push({r: 0, c: i});
        edges.push({r: this.size-1, c: i});
        edges.push({r: i, c: 0});
        edges.push({r: i, c: this.size-1});
      }
      
      for (const pos of edges) {
        if (this.board[pos.r][pos.c] === null) return pos;
      }
      
      return null;
    },
    
    getLibertyPositions(group) {
      const liberties = [];
      const seen = new Set();
      
      group.forEach(({r, c}) => {
        const neighbors = [
          {r: r-1, c},
          {r: r+1, c},
          {r, c: c-1},
          {r, c: c+1}
        ];
        
        neighbors.forEach(({r: nr, c: nc}) => {
          if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size) {
            if (this.board[nr][nc] === null) {
              const key = `${nr},${nc}`;
              if (!seen.has(key)) {
                seen.add(key);
                liberties.push({r: nr, c: nc});
              }
            }
          }
        });
      });
      
      return liberties;
    }
  },

  entityTypes: [
    {
      id: 'gatherer',
      name: 'Sbƒõraƒç',
      icon: 'üë§',
      actions: [
        {
          name: 'üî™Sb√≠rat materi√°ly',
          duration: 1,
          requires: { knife: 1 },
          result: () => {
            const items = ['wood', 'stone', 'fiber', 'mushroom'];
            const item = items[Math.floor(Math.random() * items.length)];
            return { [item]: Math.floor(Math.random() * 3) + 8 };
          }
        },
        {
          name: 'üß∫Sb√≠rat bobule',
          duration: 1,
          requires: { basket: 1 },
          result: () => ({ 
            berries: Math.floor(Math.random() * 4) + 3,
            water_supply: Math.random() > 0.5 ? Math.floor(Math.random() * 2) + 6 : 0
          })
        },
        {
          name: 'üé£Chytat ryby',
          duration: 1,
          requires: { rope: 1 },
          result: () => ({ 
            fish: Math.floor(Math.random() * 3) + 2
          })
        },
        {
          name: 'üï∏Ô∏èNastra≈æit past',
          duration: 2,
          requires: { trap: 1 },
          result: () => ({ 
            food: Math.floor(Math.random() * 5) + 4
          })
        },
        {
          name: 'ü•£Sb√≠rat vodu',
          duration: 1,
          requires: { bowl: 1 },
          result: () => ({ water_supply: Math.floor(Math.random() * 5) + 10 })
        },
        {
          name: 'üå≥Topit v krbu',
          icon: 'üå≥',
          duration: 1,
          requires: { fireplace: 1 },
          isHeating: true,
          result: () => ({ heating: 1 })
        },
        // üî• NEW ACTION - P≈ôilo≈æit do ohnƒõ
        {
          name: 'üå≥P≈ôilo≈æit do ohnƒõ',
          duration: 1,
          requiresFire: true,
          isFuelAction: true,
          result: () => ({ fireFuel: 2 })
        },
        {
          name: '‚öîÔ∏èHl√≠dat doupƒõ',
          duration: 1,
          isGuarding: true,
          result: () => ({ })
        }
      ]
     },
     {
      id: 'hunter',
      name: 'Lovec',
      icon: 'üèπ',
      unlockRequires: { bow: 1 },
      actions: [
        {
          name: 'Lovit',
          duration: 2,
          requires: { bow: 1 },
          result: () => ({ 
            food: Math.floor(Math.random() * 6) + 5,
            leather: Math.random() > 0.5 ? 1 : 0
          })
        }
      ]
     }
 ],

  // Google Analytics 4 - Server-Side Tracking
  track(eventName, params = {}) {
    // Server-side tracking p≈ôes Google Apps Script backend
    // Measurement Protocol API zaji≈°≈•uje spolehliv√© mƒõ≈ôen√≠ bez cookies/iframe omezen√≠
    try {
      const clientId = this.state.playerId; // Pou≈æij player ID jako client_id
      
      if (clientId) {
        // Use hybrid backend adapter
        this.backend('trackEvent', { clientId, eventName, params })
          .then(() => {
            // Success - tich√© logov√°n√≠ (neru≈°√≠ hr√°ƒçe)
            console.log('‚úì GA4 tracked:', eventName);
          })
          .catch((error) => {
            // Failure - tich√© logov√°n√≠ (tracking nesm√≠ crashnout hru)
            console.warn('GA4 tracking failed:', error);
          });
      }
    } catch(e) {
      // Catch any errors - tracking nesm√≠ nikdy crashnout hru
      console.warn('GA4 tracking error:', e);
    }
  },

  calculateTemperature() {
    const season = this.seasons[this.state.season];
    let targetTemp;
    
    // Use real weather if available
    if (this.state.weatherMode !== 'game' && this.state.weatherData && this.state.weatherData.temperature !== null) {
      targetTemp = this.state.weatherData.temperature;
    } else {
      // Game mode - n√°hodn√° teplota podle sez√≥ny
      const variance = (Math.random() - 0.5) * 2 * season.tempVariance;
      targetTemp = season.baseTemp + variance;
    }
    
    // Heating bonus (ka≈æd√© topen√≠ = +5¬∞C, max 3 dny)
    const heatingBonus = Math.min(this.state.heating, 3) * 5;
    
    // Shelter bonus (lep≈°√≠ izolace = men≈°√≠ rozd√≠l od ide√°ln√≠ teploty)
    const insulations = this.state.inventory.insulation || 0;
    const shelterLevel = 1 + (insulations * 0.5);
    
    // Pokud je venku moc chladno/teplo, shelter pom√°h√°
    const idealTemp = 15;
    const diff = targetTemp - idealTemp;
    const shelteredDiff = diff / shelterLevel;
    
    targetTemp = idealTemp + shelteredDiff + heatingBonus;
    
    this.state.temperature = Math.round(targetTemp * 10) / 10;
    this.state.shelterLevel = shelterLevel;
  },

  getTemperatureEmoji(temp) {
    if (temp < -5) return 'ü•∂';
    if (temp < 5) return '‚ùÑÔ∏è';
    if (temp < 12) return 'üå°Ô∏è';
    if (temp < 20) return 'üå§Ô∏è';
    if (temp < 28) return '‚òÄÔ∏è';
    return 'üî•';
  },

  getTemperatureEffects() {
    const temp = this.state.temperature;
    let hungerMultiplier = 1;
    let waterMultiplier = 1;
    let efficiency = 1;
    
    // P≈ô√≠li≈° chladno
    if (temp < 5) {
      hungerMultiplier = 1.5;
      efficiency = 0.7;
    } else if (temp < 10) {
      hungerMultiplier = 1.2;
      efficiency = 0.85;
    }
    
    // P≈ô√≠li≈° teplo
    if (temp > 28) {
      waterMultiplier = 1.5;
      efficiency = 0.7;
    } else if (temp > 23) {
      waterMultiplier = 1.2;
      efficiency = 0.85;
    }
    
    // Ide√°ln√≠ teplota (10-20¬∞C)
    if (temp >= 10 && temp <= 20) {
      efficiency = 1.1; // bonus!
    }
    
    return { hungerMultiplier, waterMultiplier, efficiency };
  },
  // üî• UPDATE FIRE INDICATOR UI
  updateFireIndicator() {
    const indicator = document.getElementById('fire-indicator');
    const statusText = indicator.querySelector('.fire-status');
    
    if (this.state.fireActive) {
      indicator.classList.remove('inactive');
      indicator.classList.add('active');
      statusText.textContent = this.state.fireFuel > 0 
        ? `Ho≈ô√≠ (${this.state.fireFuel}d)` 
        : 'Ho≈ô√≠ (p≈ôidej d≈ôevo!)';
    } else {
      indicator.classList.remove('active');
      indicator.classList.add('inactive');
      statusText.textContent = 'Bez ohnƒõ';
    }
  },
  
  // üìä UPDATE FOOTER STATS
  updateFooterStats() {
    const population = this.state.entities.length + 1; // +1 for player
    const bestRun = this.state.bestRun;
    
    document.getElementById('footer-stats').innerHTML = 
      `Kolonie: ${population} üë• | Rekord: <span id="footer-best-run">${bestRun}</span>d`;
  },
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üå§Ô∏è WEATHER MODE SYSTEM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  async setWeatherMode(mode) {
    const previousMode = this.state.weatherMode;
    this.state.weatherMode = mode;
    localStorage.setItem('doupe_weather_mode', mode);
    
    // Update button states
    const buttons = document.querySelectorAll('.weather-mode-btn');
    buttons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    // Reset weather data JEN kdy≈æ se ZMƒöN√ç m√≥d (ne p≈ôi opakovan√©m kliknut√≠)
    if (previousMode !== mode) {
      console.log(`üîÑ Weather mode changed: ${previousMode} ‚Üí ${mode}`);
      this.state.lastWeatherFetch = 0;
      this.state.weatherData = null;
    } else {
      console.log(`üì¶ Weather mode already active: ${mode} (keeping cache)`);
    }
    
    // Update widget
    if (mode === 'game') {
      this.updateWeatherWidgetGame();
      // Immediate update for game mode
      this.calculateTemperature();
      this.render();
    } else {
      // Wait for weather data before calculating temperature
      await this.fetchWeather();
      // Now calculate with fresh data
      this.calculateTemperature();
      this.render();
    }
    
    // Log change (only if actually changed)
    if (previousMode !== mode) {
      const modeName = mode === 'game' ? 'Hern√≠ m√≥d' : mode === 'openmeteo' ? 'Open-Meteo' : 'WeatherXM';
      this.log(`üå§Ô∏è Weather mode: ${modeName}`, 'info');
      this.showNotification(`üå§Ô∏è ${modeName}`);
    }
  },
  
  updateWeatherWidgetGame() {
    const widget = document.getElementById('weather-widget');
    if (!widget) return;
    
    // Safety check - pokud seasons je≈°tƒõ nen√≠ inicializovan√Ω
    if (!this.seasons || !this.seasons[this.state.season]) {
      widget.innerHTML = `<span class="weather-icon">üåç</span><span class="weather-info">Naƒç√≠t√°m...</span>`;
      return;
    }
    
    const season = this.seasons[this.state.season];
    widget.innerHTML = `<span class="weather-icon">${season.icon}</span><span class="weather-info">${season.name}: ${season.desc}</span>`;
    widget.style.cursor = 'default';
    widget.onclick = null;
  },
  
  // ‚ÑπÔ∏è SHOW ABOUT MODAL
  showAbout() {
    this.openModal();
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'about-modal';
    
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">‚ÑπÔ∏è O H≈òE DOUPƒö</div>
        
        <div style="text-align: left; color: #b89968; line-height: 1.6; margin: 20px 0;">
          <p style="margin-bottom: 15px;">
            <strong style="color: #d4a574;">Doupƒõ v2.0</strong> je survival crafting hra 
            o p≈ôe≈æit√≠ kolonie v drsn√©m prost≈ôed√≠.
          </p>
          
          <p style="margin-bottom: 15px;">
            üéØ <strong>C√≠l:</strong> Udr≈æet kolonii na≈æivu co nejd√©le. 
            Sb√≠rej suroviny, craftuj n√°stroje, p≈ôij√≠mej obyvatele a p≈ôekon√°vej roƒçn√≠ obdob√≠.
          </p>
          <b><p>v. 2.35g</p></b>
            üî• <strong>Nov√© minihry a recepty</strong><br>
            ‚Ä¢ Nov√© craft recipes - to mus√≠≈° zkusit<br>
			‚Ä¢ Nov√© minihry - k Pi≈°kvork√°m p≈ôibyla hra GO<br>
			‚Ä¢ Nov√© minihry - basic D&D diceroll<br>
			‚Ä¢ Ladƒõn√≠ aplikace
          <b><p>v. 2.12m</p></b>
            üî• <strong>Nov√© features</strong><br>
            ‚Ä¢ Potvrzen√≠ restartu hry a stats<br>
            ‚Ä¢ Hrozby a souboje - pi≈°kvorky<br>
            ‚Ä¢ P≈ôid√°na atmosferick√° hudba a controls, device recognition w. sample rate adjust<br>
            ‚Ä¢ P≈ôep√≠n√°n√≠ mezi mody poƒças√≠ s ovlivnƒõn√≠m hry<br>
            ‚Ä¢ Nov√° patiƒçka
          <b><p>v. 2.0</p></b>
          <p style="margin-bottom: 15px;">
            üî• <strong>Mechaniky:</strong><br>
            ‚Ä¢ Sez√≥nn√≠ zmƒõny ka≈æd√Ωch 15 dn√≠<br>
            ‚Ä¢ Syst√©m teploty a vyt√°pƒõn√≠<br>
            ‚Ä¢ Ohe≈à a su≈°en√≠ masa<br>
            ‚Ä¢ Ekonomika - prod√°vej a nakupuj<br>
            ‚Ä¢ ≈Ωeb≈ô√≠ƒçek nejlep≈°√≠ch koloni√≠
          </p>
          
          <p style="margin-bottom: 15px;">
            üë§ <strong>Autor:</strong> Ondrex's Ember üî•<br>
            üìÖ <strong>Verze:</strong> Doupƒõ 2 (√önor 2026)<br>
            üîß <strong>Tech:</strong> Google Apps Script + Sheets<br>
            üì¨ <strong>Bugs</strong> Opinions? Hate? Contact me by mail: ondrex@gmail.com
          </p>
          
          <p style="font-size: 11px; opacity: 0.7; margin-top: 20px;">
            üí° Tip: Nejlep≈°√≠ strategie je vyv√°≈æit craftov√°n√≠ n√°stroj≈Ø, 
            budov√°n√≠ infrastruktury a udr≈æov√°n√≠ z√°sob. Nezapome≈à na zimu!
          </p>
        </div>
        
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-primary" onclick="game.closeModal('about-modal')">
            üëç Rozum√≠m
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
  },
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ö†Ô∏è CRITICAL FUNCTION - GAME INITIALIZATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * üéÆ INIT GAME
   * 
   * Inicializuje hru - nastav√≠ player ID, naƒçte best run, vytvo≈ô√≠ poƒç√°teƒçn√≠ state,
   * detekuje environment (Apps Script vs standalone), spust√≠ GA4 tracking,
   * zobraz√≠ √∫vodn√≠ log messages.
   * 
   * ‚ö†Ô∏è MUS√ç b√Ωt vol√°no p≈ôi naƒçten√≠ str√°nky!
   * 
   * @returns {void}
   * @fires game.render() - Initial render
   * @fires game.track() - GA4 tracking events
   * @sideeffects Creates player ID, loads localStorage data, logs to game log
   * 
   * @example
   * window.onload = () => game.init(); // Vol√° se automaticky
   * 
   * @tested ‚úÖ 2026-02-08 - Works in both modes
   */
  init() {
    // Player ID syst√©m
    let playerId = localStorage.getItem('doupe_player_id');
    if (!playerId) {
      playerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('doupe_player_id', playerId);
    }
    this.state.playerId = playerId;
    
    // Naƒçti best run a nickname
    this.state.bestRun = parseInt(localStorage.getItem('doupe_best_run') || '0');
    this.state.playerNickname = localStorage.getItem('doupe_nickname') || null;
    
    this.state.inventory = { 
      wood: 5,
      fiber: 8,
      food: 60,
      water_supply: 60
    };
    this.state.season = 0; // Jaro
    this.state.day = 1;
    this.state.entities = [];
    this.state.gold = 0;
    this.state.temperature = 15;
    this.state.shelterLevel = 1;
    this.state.heating = 0;
    this.state.guaranteedStones = 0;
    this.state.fireActive = false; // üî•
    this.state.fireFuel = 0; // üî•
    
    // üî• Stop fire crackling if playing
    if (window.fireCrackle) {
      window.fireCrackle.stop();
    }
    
    this.state.weatherMode = localStorage.getItem('doupe_weather_mode') || 'game'; // üå§Ô∏è
    this.state.weatherData = null;
    this.state.lastWeatherFetch = 0;
    this.state.lastSeasonalThreat = 0;
    this.state.randomThreatCount = 0;
    this.state.maxRandomThreats = 3;
    this.state.threatCooldown = 3;
    this.state.unlockedRecipes = ['stick', 'rope', 'bowl', 'trap', 'basket'];
    
    // üìö BOOKS & KNOWLEDGE SYSTEM
    this.state.books = []; // Array of book objects: { id, title, author, pages: [] }
    this.state.accountingBonus = false; // +10% gold when ledger crafted
    
    // üõ¢Ô∏è STORAGE SYSTEM
    this.state.waterCapacity = 50; // Base capacity, +50 per barrel
    this.state.foodCapacity = 150; // Base capacity
    
    // üåê Environment Detection
    const environment = this.isAppsScript ? 'Apps Script (Full Features)' : 'Standalone (Local Save)';
    console.log(`üéÆ Doupƒõ 2 - Running in: ${environment}`);
    
    // GA4 Tracking - Page View
    this.track('page_view', {
      page_title: 'Doupƒõ - Survival Crafting',
      page_location: window.location.href,
      engagement_time_msec: '100',
      environment: environment
    });
    
    // GA4 Tracking - Game Start
    this.track('game_start', {
      starting_food: 60,
      starting_water: 60,
      starting_temperature: 15,
      is_returning_player: this.state.bestRun > 0,
      environment: environment
    });
    
    // Atmosf√©rick√Ω √∫vod
    this.log('üå≤ Probouz√≠≈° se v tich√©m doupƒõti, kdesi hluboko v temn√Ωch vla≈æn√Ωch les√≠ch... V√≠≈°, ≈æe kolem to v≈ôe, ale tobƒõ je p≈ô√≠jemnƒõ chladno.', 'info');
    this.log('Vzduch je ale tƒõ≈æk√Ω. Kolonie str√°d√° a nach√°z√≠ se na pokraji z√°niku. Hlad, ≈æ√≠ze≈à, mr√°z - tvoji vƒõƒçn√≠ nep≈ô√°tel√©.', 'warning');
    this.log('L√©ta sucha vysu≈°ila prameny. Zimy jsou krut√©, j√≠dlo vz√°cn√©. P≈ôe≈æit√≠ nen√≠ zaruƒçeno. Sp√≠≈°e vyvr√°ceno. M√°≈° na to?', 'warning');
    this.log('', 'info');
    this.log('üí° JAK ZAƒå√çT: Vytvo≈ô si n√°stroje (h≈Øl, provaz, misku). Postavte past na zvƒõ≈ô. Tvoje role je tvo≈ôit vƒõci. Pro kolonii. Obchodn√≠ci je r√°di vykoup√≠, nebo pomohou kolonii k p≈ôe≈æit√≠. V√Ωhodnou je, ≈æe je m≈Ø≈æe≈° prodat. A za pen√≠ze pak m≈Ø≈æe≈° podpo≈ôit j√≠dlem a vodou celou kolonii. Zajist√≠≈° si i tak sv√© p≈ôe≈æit√≠? Ven se ti moc zat√≠m nechce, ani na to nem√°≈° pr√°vo, tvoje role je craftov√°n√≠.', 'success');
    this.log('üí° PRVN√ç KROKY: Craftuj n≈Ø≈æ ‚Üí p≈ôijde obyvatel ‚Üí p≈ôi≈ôaƒè mu pr√°ci.', 'success');
    this.log('üí° KL√çƒå K P≈òE≈ΩIT√ç: Sledujte z√°soby kolonie! Obdob√≠ se mƒõn√≠ ka≈æd√Ωch 15 dn√≠ a jejich dopady jsou nemilosrdn√©.', 'danger');
    this.log('üí° TEPLOTA: V l√©tƒõ je vedro k omdlen√≠. V mrazu spot≈ôebujete v√≠c j√≠dla. Rozdƒõlejte ohe≈à, postavte krb, zatopte, nebo budete mrznout. Mo≈æn√° p≈ôe≈æijete zimu a dal≈°√≠ bude lehƒç√≠?', 'danger');
    this.log('üî• OHE≈á: Luk ‚Üí Bow Drill (80%) nebo K≈ôesadlo (100%). Pot≈ôebn√Ω pro su≈°en√≠ masa! P≈†≈†≈†≈†T "a dost!", ".. yes my master!"', 'success');
    this.log('üí∞ EKONOMIKA: Prod√°vej suroviny üü° za zlato ‚Üí Kup j√≠dlo/vodu üè∑Ô∏è. Risk vs. reward!', 'success');
    
    // Environment indicator
    if (!this.isAppsScript) {
      this.log('‚ö†Ô∏è Public message: Save/Load games funguje. Nov√© features. Pln√© funkce, enjoy:-).', 'warning');
    }
    
    this.log('', 'info');
    
    // üå§Ô∏è WEATHER: Inicializuj widget P≈òED render (game mode pot≈ôebuje seasons)
    if (this.state.weatherMode === 'game') {
      this.updateWeatherWidgetGame();
    }
    
    this.render();
    
    // üìÇ AUTO-LOAD: Nab√≠dni naƒçten√≠ ulo≈æen√© hry
    this.checkAutoLoad();
    
    // üå§Ô∏è WEATHER: Naƒçti extern√≠ data (async)
    if (this.state.weatherMode !== 'game') {
      setTimeout(() => {
        this.fetchWeather();
      }, 100);
    }
  },

  /**
   * üìÇ CHECK AUTO-LOAD
   * 
   * Zkontroluje jestli existuje ulo≈æen√° hra a pokud ano,
   * automaticky zobraz√≠ modal pro naƒçten√≠ p≈ôi startu.
   * 
   * @returns {void}
   * @sideeffects May call loadGame() to show modal
   * 
   * @tested ‚úÖ 2026-02-08
   */
  checkAutoLoad() {
    // Poƒçkej a≈æ se UI vykresl√≠
    setTimeout(() => {
      // Zkontroluj jestli existuje save
      let hasSave = false;
      let saveData = null;
      
      if (this.isAppsScript) {
        // V Apps Script re≈æimu zkontroluj backend
        // (zat√≠m nech√°me na manu√°ln√≠m naƒçten√≠, proto≈æe async)
        console.log('üåê Apps Script mode - auto-load skipped (use manual load)');
        return;
      } else {
        // Standalone - zkontroluj localStorage
        const saved = localStorage.getItem('doupe_save');
        if (saved) {
          try {
            saveData = JSON.parse(saved);
            hasSave = true;
          } catch(e) {
            console.error('Invalid save data:', e);
          }
        }
      }
      
      // Pokud existuje save a nen√≠ to den 1, nab√≠dni naƒçten√≠
      if (hasSave && saveData && saveData.day > 1) {
        console.log('üìÇ Auto-load: Found save on day', saveData.day);
        this.loadGame();
      } else {
        console.log('üìÇ Auto-load: No valid save found or day 1');
      }
    }, 500); // Poƒçkej 500ms aby se UI stihlo vyrenderovat
  },

  /**
   * üå§Ô∏è FETCH WEATHER
   * 
   * Naƒçte poƒças√≠ podle m√≥du:
   * - game: zobraz√≠ hern√≠ sez√≥nu
   * - openmeteo: Open-Meteo API (client-side, 10min local cache)
   * - weatherxm: WeatherXM PRO backend (server-side GLOB√ÅLN√ç cache 3h pro v≈°echny u≈æivatele)
   * 
   * @returns {Promise<void>}
   * @sideeffects Updates #weather-widget DOM element
   * 
   * @api Open-Meteo (free, no API key needed)
   * @api WeatherXM PRO (limit 500 calls/mƒõs√≠c, GLOB√ÅLN√ç CACHE na serveru)
   * @tested ‚úÖ 2026-02-10
   */
  async fetchWeather() {
    const mode = this.state.weatherMode || 'game';
    
    // Game mode - zobraz hern√≠ sez√≥nu
    if (mode === 'game') {
      this.updateWeatherWidgetGame();
      return;
    }
    
    // üì¶ ZOBRAZ LOADING STATE
    const widget = document.getElementById('weather-widget');
    if (widget) {
      widget.innerHTML = `
        <span class="weather-icon">‚è≥</span>
        <span class="weather-info">Naƒç√≠t√°m poƒças√≠...</span>
      `;
    }
    
    const now = Date.now();
    
    try {
      if (mode === 'openmeteo') {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üåç OPEN-METEO (client-side, local cache 10min)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Local cache check (neomezen√© calls, tak≈æe 10min je OK)
        if (this.state.weatherData && this.state.weatherData.source === 'openmeteo') {
          if ((now - this.state.lastWeatherFetch) < 600000) { // 10 min
            console.log(`üì¶ Using cached openmeteo data (${Math.round((now - this.state.lastWeatherFetch) / 60000)} min old)`);
            this.updateWeatherWidgetExternal();
            return;
          }
        }
        
        console.log('üåç Fetching Open-Meteo data (client-side)...');
        
        const lat = 50.7667;
        const lon = 14.5333;
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code,wind_speed_10m&timezone=Europe/Prague`;
        
        const response = await fetch(url);
        const data = await response.json();
        
        this.state.weatherData = {
          source: 'openmeteo',
          temperature: Math.round(data.current.temperature_2m),
          weatherCode: data.current.weather_code,
          windSpeed: Math.round(data.current.wind_speed_10m),
          timestamp: new Date().toISOString(),
          rawData: data
        };
        
        console.log('‚úÖ Open-Meteo data loaded:', this.state.weatherData);
        
      } else if (mode === 'weatherxm') {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // üì° WEATHERXM PRO (server-side, GLOB√ÅLN√ç cache 3h)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        console.log('üì° Calling WeatherXM backend (global cache)...');
        const response = await this.backend('fetchWeatherXM');
        
        console.log('üì° Backend response:', response);
        
        if (!response) {
          throw new Error('Backend vr√°til null response');
        }
        
        if (!response.success) {
          throw new Error(response.error || 'Backend returned success: false');
        }
        
        if (!response.data) {
          throw new Error('Backend response missing data field');
        }
        
        // Validace dat
        if (response.data.temperature === null || response.data.temperature === undefined) {
          console.warn('‚ö†Ô∏è Temperature is null/undefined:', response.data);
        }
        
        this.state.weatherData = {
          source: 'weatherxm',
          temperature: response.data.temperature,
          humidity: response.data.humidity,
          pressure: response.data.pressure,
          windSpeed: response.data.windSpeed,
          windDirection: response.data.windDirection,
          precipitation: response.data.precipitation,
          timestamp: response.data.timestamp,
          stationName: response.data.stationName,
          stationQuality: response.data.stationQuality
        };
        
        console.log('‚úÖ Weather Station data loaded:', this.state.weatherData);
      }
      
      this.state.lastWeatherFetch = now;
      this.updateWeatherWidgetExternal();
      
    } catch(error) {
      console.error('‚ùå Weather fetch failed:', error);
      console.error('‚ùå Error details:', {
        mode: mode,
        message: error.message,
        stack: error.stack
      });
      
      const widget = document.getElementById('weather-widget');
      if (widget) {
        widget.innerHTML = `
          <span class="weather-icon">‚ùå</span>
          <span class="weather-info">Chyba: ${error.message}</span>
        `;
      }
    }
  },
  
  updateWeatherWidgetExternal() {
    const widget = document.getElementById('weather-widget');
    if (!widget || !this.state.weatherData) return;
    
    const data = this.state.weatherData;
    
    if (data.source === 'openmeteo') {
      const weatherInfo = this.getWeatherInfo(data.weatherCode);
      widget.innerHTML = `
        <span class="weather-icon">${weatherInfo.icon}</span>
        <span class="weather-info">
          Nov√Ω Bor: ${data.temperature}¬∞C, ${weatherInfo.desc}${data.windSpeed > 20 ? ' üí®' : ''}
        </span>
      `;
    } else if (data.source === 'weatherxm') {
      const temp = data.temperature !== null ? Math.round(data.temperature) : '?';
      const humidity = data.humidity !== null ? Math.round(data.humidity) : '?';
      const stationName = data.stationName || 'WeatherXM';
      widget.innerHTML = `
        <span class="weather-icon">üì°</span>
        <span class="weather-info">
          ${stationName}: ${temp}¬∞C, ${humidity}%
        </span>
      `;
    }
    
    widget.style.cursor = 'pointer';
    widget.onclick = () => this.showWeatherDetail();
  },

  /**
   * ‚è∞ GET TIME AGO
   * 
   * P≈ôevede timestamp na ƒçiteln√Ω "p≈ôed X minutami/hodinami"
   * 
   * @param {string} timestamp - ISO timestamp
   * @returns {string} ƒåiteln√Ω ƒças (nap≈ô. "p≈ôed 2 hodinami")
   */
  getTimeAgo(timestamp) {
    const now = Date.now();
    const then = new Date(timestamp).getTime();
    const diffMs = now - then;
    const diffMin = Math.floor(diffMs / 60000);
    
    if (diffMin < 1) return 'pr√°vƒõ teƒè';
    if (diffMin === 1) return 'p≈ôed minutou';
    if (diffMin < 60) return `p≈ôed ${diffMin} minutami`;
    
    const diffHours = Math.floor(diffMin / 60);
    if (diffHours === 1) return 'p≈ôed hodinou';
    if (diffHours < 24) return `p≈ôed ${diffHours} hodinami`;
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays === 1) return 'vƒçera';
    return `p≈ôed ${diffDays} dny`;
  },

  /**
   * üå¶Ô∏è GET WEATHER INFO
   * 
   * P≈ôevede WMO weather code na emoji ikonu a ƒçesk√Ω popis.
   * 
   * @param {number} code - WMO weather code
   * @returns {Object} {icon: string, desc: string}
   * 
   * @see https://open-meteo.com/en/docs
   */
  getWeatherInfo(code) {
    // WMO Weather interpretation codes
    const weatherMap = {
      0: { icon: '‚òÄÔ∏è', desc: 'jasno' },
      1: { icon: 'üå§Ô∏è', desc: 'p≈ôev√°≈ænƒõ jasno' },
      2: { icon: '‚õÖ', desc: 'polojasno' },
      3: { icon: '‚òÅÔ∏è', desc: 'zata≈æeno' },
      45: { icon: 'üå´Ô∏è', desc: 'mlha' },
      48: { icon: 'üå´Ô∏è', desc: 'jinovatka' },
      51: { icon: 'üå¶Ô∏è', desc: 'mrholen√≠' },
      53: { icon: 'üåßÔ∏è', desc: 'mrholen√≠' },
      55: { icon: 'üåßÔ∏è', desc: 'siln√© mrholen√≠' },
      61: { icon: 'üåßÔ∏è', desc: 'd√©≈°≈•' },
      63: { icon: 'üåßÔ∏è', desc: 'd√©≈°≈•' },
      65: { icon: '‚õàÔ∏è', desc: 'siln√Ω d√©≈°≈•' },
      71: { icon: 'üå®Ô∏è', desc: 'snƒõ≈æen√≠' },
      73: { icon: 'üå®Ô∏è', desc: 'snƒõ≈æen√≠' },
      75: { icon: '‚ùÑÔ∏è', desc: 'siln√© snƒõ≈æen√≠' },
      77: { icon: 'üå®Ô∏è', desc: 'snƒõhov√© vloƒçky' },
      80: { icon: 'üå¶Ô∏è', desc: 'p≈ôeh√°≈àky' },
      81: { icon: '‚õàÔ∏è', desc: 'p≈ôeh√°≈àky' },
      82: { icon: '‚õàÔ∏è', desc: 'siln√© p≈ôeh√°≈àky' },
      85: { icon: 'üå®Ô∏è', desc: 'snƒõhov√© p≈ôeh√°≈àky' },
      86: { icon: '‚ùÑÔ∏è', desc: 'siln√© snƒõhov√© p≈ôeh√°≈àky' },
      95: { icon: '‚õàÔ∏è', desc: 'bou≈ôka' },
      96: { icon: '‚õàÔ∏è', desc: 'bou≈ôka s krupobit√≠m' },
      99: { icon: '‚õàÔ∏è', desc: 'siln√° bou≈ôka' }
    };
    
    return weatherMap[code] || { icon: 'üå§Ô∏è', desc: 'promƒõnliv√©' };
  },

  /**
   * üìä SHOW WEATHER DETAIL
   * 
   * Zobraz√≠ detailn√≠ modal s roz≈°√≠≈ôen√Ωmi informacemi o poƒças√≠.
   * 
   * @param {Object} data - Weather data from API
   * @returns {void}
   */
  showWeatherDetail() {
    const data = this.state.weatherData;
    if (!data) return;
    
    this.openModal();
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'weather-modal';
    
    let content = '';
    
    if (data.source === 'openmeteo') {
      const weatherInfo = this.getWeatherInfo(data.weatherCode);
      content = `
        <div class="modal-content">
          <div class="modal-title">üåç OPEN-METEO</div>
          
          <div style="text-align: center; margin: 30px 0;">
            <div style="font-size: 64px; margin-bottom: 10px;">
              ${weatherInfo.icon}
            </div>
            <div style="font-size: 48px; font-weight: 700; color: #d4a574; margin-bottom: 5px;">
              ${data.temperature}¬∞C
            </div>
            <div style="font-size: 18px; color: #b89968; text-transform: capitalize;">
              ${weatherInfo.desc}
            </div>
          </div>
          
          <div style="text-align: left; color: #b89968; line-height: 1.8; margin: 20px 0;">
            <p style="margin-bottom: 8px;">
              üí® <strong>V√≠tr:</strong> ${data.windSpeed} km/h
            </p>
            <p style="margin-bottom: 8px;">
              üìç <strong>Lokace:</strong> Nov√Ω Bor, ƒåesk√° republika
            </p>
            <p style="font-size: 11px; opacity: 0.7; margin-top: 15px;">
              Data z Open-Meteo API ‚Ä¢ ${this.getTimeAgo(data.timestamp)}
            </p>
            ${this.state.lastWeatherFetch > 0 ? `
              <p style="font-size: 10px; opacity: 0.6; margin-top: 5px; color: #7bc876;">
                üì¶ Dal≈°√≠ aktualizace za ${Math.round((600000 - (Date.now() - this.state.lastWeatherFetch)) / 60000)} min (cache: 10min)
              </p>
            ` : ''}
          </div>
          
          <div class="modal-buttons">
            <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('weather-modal')">
              Zav≈ô√≠t
            </button>
          </div>
        </div>
      `;
    } else if (data.source === 'weatherxm') {
      const temp = data.temperature !== null ? Math.round(data.temperature) : 'N/A';
      const humidity = data.humidity !== null ? Math.round(data.humidity) : 'N/A';
      const pressure = data.pressure !== null ? Math.round(data.pressure) : 'N/A';
      const windSpeed = data.windSpeed !== null ? Math.round(data.windSpeed) : 'N/A';
      const windDir = data.windDirection !== null ? Math.round(data.windDirection) : 'N/A';
      const precip = data.precipitation !== null ? data.precipitation.toFixed(1) : 'N/A';
      const stationName = data.stationName || 'WeatherXM Station';
      const quality = data.stationQuality !== null ? Math.round(data.stationQuality * 100) : null;
      
      content = `
        <div class="modal-content">
          <div class="modal-title">üì° WEATHER STATION</div>
          
          <div style="text-align: center; margin: 30px 0;">
            <div style="font-size: 64px; margin-bottom: 10px;">
              üì°
            </div>
            <div style="font-size: 48px; font-weight: 700; color: #d4a574; margin-bottom: 5px;">
              ${temp}¬∞C
            </div>
            <div style="font-size: 16px; color: #b89968;">
              ${stationName}
            </div>
            ${quality !== null ? `
              <div style="font-size: 12px; color: #7bc876; margin-top: 5px;">
                üìä Kvalita dat: ${quality}%
              </div>
            ` : ''}
          </div>
          
          <div style="text-align: left; color: #b89968; line-height: 1.8; margin: 20px 0;">
            <p style="margin-bottom: 10px;">
              üå°Ô∏è <strong>Teplota:</strong> ${temp}¬∞C
            </p>
            <p style="margin-bottom: 10px;">
              üíß <strong>Vlhkost:</strong> ${humidity}%
            </p>
            <p style="margin-bottom: 10px;">
              üîΩ <strong>Tlak:</strong> ${pressure} hPa
            </p>
            <p style="margin-bottom: 10px;">
              üí® <strong>V√≠tr:</strong> ${windSpeed} km/h (${windDir}¬∞)
            </p>
            <p style="margin-bottom: 10px;">
              üåßÔ∏è <strong>Sr√°≈æky:</strong> ${precip} mm/h
            </p>
            <p style="font-size: 11px; opacity: 0.7; margin-top: 15px;">
              Data z Weather Station ‚Ä¢ ${this.getTimeAgo(data.timestamp)}
            </p>
            ${this.state.lastWeatherFetch > 0 ? `
              <p style="font-size: 10px; opacity: 0.6; margin-top: 5px; color: #7bc876;">
                üì¶ Dal≈°√≠ aktualizace za ${Math.round((10800000 - (Date.now() - this.state.lastWeatherFetch)) / 60000)} min (cache: 3h)
              </p>
            ` : ''}
          </div>
          
          <div class="modal-buttons">
            <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('weather-modal')">
              Zav≈ô√≠t
            </button>
          </div>
        </div>
      `;
    }
    
    modal.innerHTML = content;
    document.body.appendChild(modal);
  },

  log(text, type = 'info') {
    const div = document.createElement('div');
    div.className = `log-entry log-${type}`;
    div.textContent = text;
    const logEl = document.getElementById('log');
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  },

  showNotification(text) {
    const notif = document.createElement('div');
    notif.className = 'event-notification';
    notif.textContent = text;
    document.body.appendChild(notif);
    
    setTimeout(() => {
      notif.style.animation = 'slideIn 0.5s ease-out reverse';
      setTimeout(() => notif.remove(), 500);
    }, 3000);
  },

  // üí∞ ECONOMY: Sell Item
  sellItem(itemId, quantity = 1) {
    const item = this.items[itemId];
    if (!item) return;
    
    const have = this.state.inventory[itemId] || 0;
    if (have < quantity) {
      this.log('‚ùå Nem√°≈° dost na prodej', 'warning');
      return;
    }
    
    if (!item.sellPrice) {
      this.log('‚ùå Toto nelze prodat', 'warning');
      return;
    }
    
    let goldEarned = item.sellPrice * quantity;
    
    // üìö ACCOUNTING BONUS: +10% gold kdy≈æ m√°≈° ledger
    if (this.state.accountingBonus) {
      goldEarned = Math.floor(goldEarned * 1.1);
    }
    
    // Update state
    this.removeItem(itemId, quantity);
    this.state.gold += goldEarned;
    
    if (soundEffects) soundEffects.playSound('sell');
    this.log(`üü° Prodal jsi ${item.icon} ${item.name} √ó${quantity} za ${goldEarned}g`, 'success');
    this.showNotification(`üü° +${goldEarned}g`);
    
    // GA4 Tracking
    this.track('item_sold', {
      item_id: itemId,
      item_name: item.name,
      quantity: quantity,
      gold_earned: goldEarned,
      new_gold_balance: this.state.gold,
      day: this.state.day
    });
    
    // Backend transaction logging (fire & forget)
    this.backend('logTransaction', {
      playerId: this.state.playerId,
      type: 'sell',
      itemId: itemId,
      itemName: item.name,
      quantity: quantity,
      goldAmount: goldEarned,
      newBalance: this.state.gold,
      day: this.state.day
    }).catch((error) => {
      console.warn('Transaction log failed:', error);
    });
    
    this.render();
  },

  // üí∞ ECONOMY: Buy Item
  buyItem(itemId, quantity = 1) {
    const item = this.items[itemId];
    if (!item) return;
    
    if (!item.buyPrice) {
      this.log('‚ùå Toto nelze koupit', 'warning');
      return;
    }
    
    let goldNeeded = item.buyPrice * quantity;
    
    // üìö ACCOUNTING BONUS: -10% cena kdy≈æ m√°≈° ledger
    if (this.state.accountingBonus) {
      goldNeeded = Math.ceil(goldNeeded * 0.9);
    }
    
    if (this.state.gold < goldNeeded) {
      this.log(`‚ùå Nem√°≈° dost zlata (pot≈ôeba ${goldNeeded}g)`, 'warning');
      return;
    }
    
    // Update state
    this.state.gold -= goldNeeded;
    this.addItem(itemId, quantity);
    
    if (soundEffects) soundEffects.playSound('buy');
    this.log(`üè∑Ô∏è Koupil jsi ${item.icon} ${item.name} √ó${quantity} za ${goldNeeded}g`, 'success');
    this.showNotification(`üè∑Ô∏è -${goldNeeded}g`);
    
    // GA4 Tracking
    this.track('item_bought', {
      item_id: itemId,
      item_name: item.name,
      quantity: quantity,
      gold_spent: goldNeeded,
      new_gold_balance: this.state.gold,
      day: this.state.day
    });
    
    // Backend transaction logging (fire & forget)
    this.backend('logTransaction', {
      playerId: this.state.playerId,
      type: 'buy',
      itemId: itemId,
      itemName: item.name,
      quantity: quantity,
      goldAmount: goldNeeded,
      newBalance: this.state.gold,
      day: this.state.day
    }).catch((error) => {
      console.warn('Transaction log failed:', error);
    });
    
    this.render();
  },

  hasMaterials(materials) {
    return Object.entries(materials).every(
      ([id, count]) => (this.state.inventory[id] || 0) >= count
    );
  },

  hasTools(tools) {
    if (!tools) return true;
    return Object.entries(tools).every(
      ([id, count]) => (this.state.inventory[id] || 0) >= count
    );
  },

  addItem(id, count) {
    this.state.inventory[id] = (this.state.inventory[id] || 0) + count;
  },

  removeItem(id, count) {
    this.state.inventory[id] = (this.state.inventory[id] || 0) - count;
    if (this.state.inventory[id] <= 0) delete this.state.inventory[id];
  },

  craft(recipeId) {
    const recipe = this.recipes.find(r => r.id === recipeId);
    if (!recipe) return;

    if (!this.hasMaterials(recipe.materials)) {
      this.log('‚ùå Nem√°≈° dost materi√°l≈Ø', 'warning');
      return;
    }

    if (recipe.requires && !this.hasTools(recipe.requires)) {
      this.log('‚ùå Pot≈ôebuje≈° spr√°vn√© n√°stroje', 'warning');
      return;
    }

    // üî• Check fire requirement
    if (recipe.requiresFire && !this.state.fireActive) {
      this.log('‚ùå Pot≈ôebuje≈° ho≈ô√≠c√≠ ohe≈à', 'warning');
      return;
    }

    // üî• FIRE STARTER RECIPES (special handling)
    if (recipe.isFireStarter) {
      // Odeƒçti materi√°ly
      for (const [id, count] of Object.entries(recipe.materials)) {
        this.removeItem(id, count);
      }

      // RNG roll
      if (Math.random() < recipe.fireChance) {
        this.state.fireActive = true;
        this.state.fireFuel = 2; // Start with 2 days of fuel
        this.log(`üî• Ohe≈à vzplanul! (${recipe.fireMethod})`, 'success');
        this.showNotification('üî• Ohe≈à ho≈ô√≠!');
        
        // üî• Start fire crackling sound (if not muted)
        const isAudioMuted = localStorage.getItem('allAudioMuted') === 'true';
        if (window.fireCrackle && !isAudioMuted) {
          window.fireCrackle.start();
        }
        
        // GA tracking
        this.track('fire_started', {
          method: recipe.fireMethod,
          day: this.state.day,
          chance: recipe.fireChance
        });
      } else {
        this.log('üí® Nepoda≈ôilo se... zkus znovu', 'warning');
        
        // GA tracking failure
        this.track('fire_failed', {
          method: recipe.fireMethod,
          day: this.state.day
        });
      }
      
      this.render();
      return;
    }

    // NORMAL CRAFTING (not fire starter)
    // Odeƒçti materi√°ly
    for (const [id, count] of Object.entries(recipe.materials)) {
      this.removeItem(id, count);
    }

    // P≈ôidej v√Ωsledek
    for (const [id, count] of Object.entries(recipe.result)) {
      this.addItem(id, count);
    }

    if (soundEffects) soundEffects.playSound('craft');
    this.log(`‚úÖ Vytvo≈ôil jsi ${recipe.icon} ${recipe.name}`, 'success');

    // GA Tracking - Craft Item
    this.track('craft_item', {
      item_name: recipe.name,
      item_id: recipe.id,
      item_tier: recipe.tier,
      day: this.state.day,
      season: this.seasons[this.state.season].name
    });

    // Unlock mechaniky
    if (recipe.unlock === 'first_entity' && this.state.entities.length === 0) {
      this.spawnEntity('gatherer');
      this.log('üë§ Do doupƒõte dorazil prvn√≠ obyvatel - Sbƒõraƒç!', 'success');
      this.showNotification('üéâ Nov√Ω obyvatel se p≈ôipojil!');
    }

    if (recipe.unlock === 'hunter_entity') {
      const hasHunter = this.state.entities.some(e => e.type === 'hunter');
      if (!hasHunter) {
        this.spawnEntity('hunter');
        this.log('üèπ Lovec se p≈ôipojil k doupƒõti!', 'success');
        this.showNotification('üéâ Lovec se p≈ôipojil!');
      }
    }
    
    // üìö ACCOUNTING BONUS UNLOCK
    if (recipe.unlock === 'accounting_bonus') {
      this.state.accountingBonus = true;
      this.log('üìö √öƒçetn√≠ kniha vytvo≈ôena! +10% gold ze v≈°ech obchod≈Ø!', 'success');
      this.showNotification('üí∞ +10% Gold Bonus!');
    }
    
    // üõ¢Ô∏è BARREL - WATER CAPACITY INCREASE
    if (recipe.id === 'barrel') {
      this.state.waterCapacity += 50;
      this.log('üõ¢Ô∏è Sud postaven! Kapacita vody +50 (celkem: ' + this.state.waterCapacity + ')', 'success');
      this.showNotification('üõ¢Ô∏è +50 Kapacita vody!');
    }

    this.render();
  },

  spawnEntity(typeId) {
    const type = this.entityTypes.find(t => t.id === typeId);
    if (!type) return;

    const entity = {
      id: Date.now(),
      type: typeId,
      name: type.name,
      icon: type.icon,
      status: 'idle',
      action: null,
      daysLeft: 0
    };

    this.state.entities.push(entity);
    
    // GA Tracking - Entity Joined
    this.track('entity_joined', {
      entity_type: typeId,
      entity_name: type.name,
      day: this.state.day,
      total_entities: this.state.entities.length
    });
  },

  assignAction(entityId, actionIndex) {
    const entity = this.state.entities.find(e => e.id === entityId);
    if (!entity) return;

    const type = this.entityTypes.find(t => t.id === entity.type);
    const action = type.actions[actionIndex];

    if (!this.hasTools(action.requires)) {
      this.log('‚ùå Entita nem√° pot≈ôebn√© n√°stroje', 'warning');
      return;
    }
    // üî• Check fire requirement for fuel action
    if (action.requiresFire && !this.state.fireActive) {
      this.log('‚ùå Nen√≠ zalo≈æen√Ω ohe≈à', 'warning');
      return;
    }
    entity.status = 'working';
    entity.action = action;
    entity.daysLeft = action.duration;

    if (soundEffects) soundEffects.playSound('gather');
    this.log(`${entity.icon} ${entity.name} zaƒçal: ${action.name}`, 'info');
    
    // GA Tracking - Entity Action
    this.track('entity_action', {
      entity_type: entity.type,
      action_name: action.name,
      action_duration: action.duration,
      day: this.state.day
    });
    
    this.render();
  },

  processEntities() {
    this.state.entities.forEach(entity => {
      if (entity.status === 'working' && entity.daysLeft > 0) {
        entity.daysLeft--;

        if (entity.daysLeft === 0) {
          // üî• FUEL ACTION (special handling)
          if (entity.action.isFuelAction) {
            const woodAvailable = this.state.inventory.wood || 0;
            if (woodAvailable >= 3) {
              this.removeItem('wood', 3);
              this.state.fireFuel += 3; // 3 wood = 2 days fuel
              this.log(`${entity.icon} ${entity.name} p≈ôilo≈æil do ohnƒõ (+2 dny, -3 ü™µ)`, 'success');
              
              // GA Tracking - Fuel Added
              this.track('fire_fueled', {
                wood_used: 3,
                fuel_added: 2,
                total_fuel: this.state.fireFuel,
                day: this.state.day
              });
            } else {
              this.log(`${entity.icon} ${entity.name} nem√° d≈ôevo (pot≈ôeba 3)`, 'warning');
            }
            entity.status = 'idle';
            entity.action = null;
            return;
          }

          // Speci√°ln√≠ zpracov√°n√≠ heating akce
          if (entity.action.isHeating) {
            const woodAvailable = this.state.inventory.wood || 0;
            if (woodAvailable >= 3) {
              this.removeItem('wood', 3);
              this.state.heating = Math.min(this.state.heating + 1, 3);
              this.log(`${entity.icon} ${entity.name} zatopil v krbu (+5¬∞C po 1 den)`, 'success');
              
              // GA Tracking - Heating
              this.track('heating_action', {
                success: true,
                heating_level: this.state.heating,
                temperature: this.state.temperature,
                day: this.state.day
              });
            } else {
              this.log(`${entity.icon} ${entity.name} nem√° d≈ôevo na topen√≠ (pot≈ôeba 3)`, 'warning');
              
              // GA Tracking - Heating Failed
              this.track('heating_action', {
                success: false,
                wood_available: woodAvailable,
                temperature: this.state.temperature,
                day: this.state.day
              });
            }
            entity.status = 'idle';
            entity.action = null;
            return;
          }
          
          // Akce dokonƒçena - norm√°ln√≠ result
          const result = entity.action.result();
          
          let resultText = [];
          for (const [itemId, count] of Object.entries(result)) {
            if (count > 0) {
              this.addItem(itemId, count);
              const item = this.items[itemId];
              resultText.push(`${item.icon} ${item.name} √ó${count}`);
            }
          }

          if (resultText.length > 0) {
            this.log(`${entity.icon} ${entity.name} p≈ôinesl: ${resultText.join(', ')}`, 'item');
          } else {
            this.log(`${entity.icon} ${entity.name} se vr√°til s pr√°zdnou`, 'warning');
          }

          entity.status = 'idle';
          entity.action = null;
        }
      }
    });
  },

  triggerRandomEvent() {
    const currentSeason = this.seasons[this.state.season];
    
    // Filtruj ud√°losti podle sez√≥ny
    const availableEvents = this.randomEvents.filter(event => {
      if (event.season && !event.season.includes(this.state.season)) {
        return false;
      }
      return true;
    });

    // N√°hodn√° ≈°ance na ud√°lost
    if (Math.random() > this.state.eventChance) return;
    if (soundEffects) soundEffects.playSound('alert');

    // Vyber ud√°lost podle vah
    const totalChance = availableEvents.reduce((sum, e) => sum + e.chance, 0);
    let roll = Math.random() * totalChance;

    for (const event of availableEvents) {
      roll -= event.chance;
      if (roll <= 0) {
        if (event.items) {
          for (const [itemId, range] of Object.entries(event.items)) {
            const count = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
            this.addItem(itemId, count);
            const item = this.items[itemId];
            this.log(event.message + ` (+${count} ${item.icon})`, 'item');
          }
        } else {
          this.log(event.message, 'info');
        }
        break;
      }
    }
  },

  nextDay() {
    if (this.state.dead) return;

    if (soundEffects) soundEffects.playSound('nextDay');
    
    this.state.day++;
    
    // üéµ AUTO-START MUSIC if not already playing
    if (window.atmosphericMusic && !window.atmosphericMusic.isPlaying) {
      const audioMuted = localStorage.getItem('allAudioMuted') === 'true';
      if (!audioMuted) {
        console.log('üéµ Auto-starting music (not playing)');
        window.atmosphericMusic.play(this.state.season, true); // forceFirstTrack = true
      }
    }

    // Zmƒõna sez√≥ny ka≈æd√Ωch 15 dn√≠
    const newSeason = Math.floor((this.state.day - 1) / 15) % 4;
    if (newSeason !== this.state.season) {
      this.state.season = newSeason;
      const season = this.seasons[this.state.season];
      this.log(`${season.icon} Nast√°v√° ${season.name}! ${season.desc}`, 'warning');
      this.showNotification(`${season.icon} ${season.name} zaƒç√≠n√°!`);
      
      // GA Tracking - Season Change
      this.track('season_change', {
        new_season: season.name,
        day: this.state.day,
        population: this.state.entities.length + 1,
        food_reserves: this.state.inventory.food || 0,
        water_reserves: this.state.inventory.water_supply || 0
      });
    }

    // GA Tracking - Day Milestones
    if (this.state.day % 10 === 0) {
      this.track('milestone_reached', {
        days_survived: this.state.day,
        season: this.seasons[this.state.season].name,
        population: this.state.entities.length + 1,
        temperature: this.state.temperature,
        food_supply: this.state.inventory.food || 0,
        water_supply: this.state.inventory.water_supply || 0
      });
    }

    const season = this.seasons[this.state.season];

    this.log(`--- Den ${this.state.day} ---`, 'info');
    // üî• FIRE DECAY
    if (this.state.fireFuel > 0) {
      this.state.fireFuel--;
      
      // ‚ö´ COAL GENERATION: Po 1 dni ho≈ôen√≠ zbydou 2 uhl√≠
      this.addItem('coal', 2);
      this.log('‚ö´ Z ohnƒõ zbylo uhl√≠ (+2)', 'item');
      
      if (this.state.fireFuel === 0) {
        this.state.fireActive = false;
        this.log('üå´Ô∏è Ohe≈à vyhasl!', 'warning');
        this.showNotification('üí® Ohe≈à vyhasl!');
        
        // üî• Stop fire crackling sound
        if (window.fireCrackle) {
          window.fireCrackle.stop();
        }
        
        // GA Tracking - Fire Extinguished
        this.track('fire_extinguished', {
          day: this.state.day,
          reason: 'no_fuel'
        });
      } else {
        this.log(`üî• Ohe≈à ho≈ô√≠ (zb√Ωv√° ${this.state.fireFuel} dn√≠)`, 'info');
      }
    }
    // V√Ωpoƒçet teploty
    this.calculateTemperature();
    const tempEffects = this.getTemperatureEffects();
    const tempEmoji = this.getTemperatureEmoji(this.state.temperature);
    
    // Temperature warning
    if (this.state.temperature < 5) {
      this.log(`${tempEmoji} Je mrazivƒõ! (${this.state.temperature}¬∞C) Spot≈ôeba j√≠dla +50%`, 'danger');
      // GA Tracking - Extreme Cold
      this.track('extreme_temperature', {
        type: 'freezing',
        temperature: this.state.temperature,
        day: this.state.day,
        heating_active: this.state.heating > 0
      });
    } else if (this.state.temperature < 10) {
      this.log(`${tempEmoji} Je chladno (${this.state.temperature}¬∞C) Spot≈ôeba j√≠dla +20%`, 'warning');
    } else if (this.state.temperature > 28) {
      this.log(`${tempEmoji} Je vedro! (${this.state.temperature}¬∞C) Spot≈ôeba vody +50%`, 'danger');
      // GA Tracking - Extreme Heat
      this.track('extreme_temperature', {
        type: 'heatwave',
        temperature: this.state.temperature,
        day: this.state.day
      });
    } else if (this.state.temperature > 23) {
      this.log(`${tempEmoji} Je horko (${this.state.temperature}¬∞C) Spot≈ôeba vody +20%`, 'warning');
    } else if (this.state.temperature >= 10 && this.state.temperature <= 20) {
      this.log(`${tempEmoji} P≈ô√≠jemn√° teplota (${this.state.temperature}¬∞C) Efektivita +10%!`, 'success');
    } else {
      this.log(`${tempEmoji} Teplota: ${this.state.temperature}¬∞C`, 'info');
    }
    
    // Heating decay
    if (this.state.heating > 0) {
      this.state.heating--;
      if (this.state.heating === 0) {
        this.log('üî• Krb vychladl', 'info');
      }
    }

    // Zpracuj entity
    this.processEntities();

    // Garantovan√© kameny prvn√≠ch 5 dn√≠ (min 2, max 3)
    if (this.state.day <= 5) {
      const stonesGiven = this.state.guaranteedStones || 0;
      
      if (stonesGiven < 2) {
        // Je≈°tƒõ nem√°me 2 ‚Üí zagarantovat 1 k√°men
        this.addItem('stone', 1);
        this.log(`‚õ∞Ô∏è Na≈°el jsi k√°men! (+1)`, 'item');
        this.state.guaranteedStones = stonesGiven + 1;
      } else if (stonesGiven === 2 && Math.random() < 0.5) {
        // M√°me 2, ≈°ance 50% na 3.
        this.addItem('stone', 1);
        this.log(`‚õ∞Ô∏è Na≈°el jsi k√°men! (+1)`, 'item');
        this.state.guaranteedStones = 3;
      }
    }

    // N√°hodn√° ud√°lost
    this.triggerRandomEvent();

    // üó°Ô∏è Check for threats
    this.checkThreats();

    // Denn√≠ spot≈ôeba podle sez√≥ny + POPULATION SCALING + TEMPERATURE EFFECTS
    // Prvn√≠ entita je "free" (z√°kladn√≠ spot≈ôeba), ka≈æd√° dal≈°√≠ +40%
    const effectivePopulation = Math.max(0, this.state.entities.length - 1);
    const populationMultiplier = 1 + (effectivePopulation * 0.4);
    
    const hungerNeeded = Math.ceil(season.hungerDrain * populationMultiplier * tempEffects.hungerMultiplier);
    const waterNeeded = Math.ceil(season.waterDrain * populationMultiplier * tempEffects.waterMultiplier);
    
    const foodAvailable = this.state.inventory.food || 0;
    const waterAvailable = this.state.inventory.water_supply || 0;

    // Info o populaci
    if (this.state.entities.length > 0) {
      this.log(`üë• Kolonie: ${this.state.entities.length + 1} obyvatel (spot≈ôeba: √ó${populationMultiplier.toFixed(1)})`, 'info');
    }

    // Spot≈ôebuj j√≠dlo
    if (foodAvailable >= hungerNeeded) {
      this.removeItem('food', hungerNeeded);
      this.log(`üçñ Spot≈ôebov√°no ${hungerNeeded} j√≠dla`, 'info');
    } else {
      if (foodAvailable > 0) {
        this.removeItem('food', foodAvailable);
        this.log(`‚ö†Ô∏è Spot≈ôebov√°no jen ${foodAvailable} j√≠dla, chyb√≠ ${hungerNeeded - foodAvailable}`, 'warning');
      }
      this.gameOver('üçñ Kolonie um≈ôela hlady');
      return;
    }

    // Po zmƒõnƒõ sez√≥ny
    if (this.state.day % 15 === 0) {
    if (window.atmosphericMusic) {
    window.atmosphericMusic.changeSeason(this.state.season);
    }
    }

    // Spot≈ôebuj vodu
    if (waterAvailable >= waterNeeded) {
      this.removeItem('water_supply', waterNeeded);
      this.log(`üíß Spot≈ôebov√°no ${waterNeeded} vody`, 'info');
    } else {
      if (waterAvailable > 0) {
        this.removeItem('water_supply', waterAvailable);
        this.log(`‚ö†Ô∏è Spot≈ôebov√°na jen ${waterAvailable} voda, chyb√≠ ${waterNeeded - waterAvailable}`, 'warning');
      }
      this.gameOver('üíß Kolonie um≈ôela ≈æ√≠zn√≠');
      return;
    }

    this.render();
  },

  gameOver(reason = 'Nep≈ôe≈æil jsi') {
    this.state.dead = true;
    
    // Zkontroluj jestli je to nov√Ω osobn√≠ rekord
    const isNewBestRun = this.state.day > this.state.bestRun;
    
    // GA Tracking - Game Over (detailed)
    this.track('game_over', {
      death_reason: reason,
      days_survived: this.state.day,
      final_season: this.seasons[this.state.season].name,
      population: this.state.entities.length + 1,
      final_temperature: this.state.temperature,
      food_remaining: this.state.inventory.food || 0,
      water_remaining: this.state.inventory.water_supply || 0,
      had_fireplace: (this.state.inventory.fireplace || 0) > 0,
      had_insulation: (this.state.inventory.insulation || 0) > 0,
      shelter_level: this.state.shelterLevel,
      fire_was_active: this.state.fireActive, // üî•
      is_new_best: isNewBestRun
    });
    
    // Pokud je nov√Ω rekord, zobraz nickname modal m√≠sto bƒõ≈æn√©ho game over
    if (isNewBestRun) {
      this.showNicknameModal(reason);
      return;
    }
    
    // Bƒõ≈æn√Ω game over screen
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeIn 0.5s ease-out;
    `;
    overlay.innerHTML = `
      <div style="
        background: linear-gradient(145deg, #1a1410, #2d2416);
        padding: 50px;
        border-radius: 24px;
        text-align: center;
        border: 2px solid rgba(192, 80, 77, 0.5);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
        animation: scaleIn 0.5s ease-out 0.2s both;
      ">
        <h1 style="
          color: #e67e7b;
          font-size: 48px;
          margin-bottom: 20px;
          font-family: 'Space Mono', monospace;
          text-shadow: 0 4px 12px rgba(230, 126, 123, 0.5);
        ">üíÄ GAME OVER</h1>
        <p style="
          color: #d4a574;
          font-size: 20px;
          margin-bottom: 30px;
          font-family: 'Crimson Pro', serif;
        ">${reason}</p>
        <p style="
          color: #9a8670;
          font-size: 16px;
          margin-bottom: 30px;
          font-family: 'Space Mono', monospace;
        ">P≈ôe≈æil jsi ${this.state.day} dn√≠</p>
        <button onclick="game.confirmReset()" style="
          padding: 16px 32px;
          font-size: 18px;
          background: linear-gradient(135deg, #8b5a2b, #a67c52);
          color: white;
          border: none;
          border-radius: 12px;
          cursor: pointer;
          font-family: 'Space Mono', monospace;
          font-weight: 700;
          box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        ">üîÑ Zkusit znovu</button>
      </div>
    `;
    
    const style = document.createElement('style');
    style.textContent = `
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      @keyframes scaleIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }
    `;
    document.head.appendChild(style);
    
    document.body.appendChild(overlay);
  },

  showNicknameModal(reason) {
    // Lock scroll
    this.openModal();
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'nickname-modal';
    
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">üéâ NOV√ù OSOBN√ç REKORD!</div>
        <p class="nickname-info">P≈ôe≈æil jsi <strong>${this.state.day} dn√≠</strong></p>
        <p class="nickname-info" style="font-size: 12px; color: #9a8670; margin-top: -5px;">
          P≈ôedchoz√≠ rekord: ${this.state.bestRun} dn√≠
        </p>
        <p class="nickname-info" style="margin-top: 15px;">Zadej svou p≈ôezd√≠vku pro ≈æeb≈ô√≠ƒçek:</p>
        <input 
          type="text" 
          class="nickname-input" 
          id="nickname-input"
          placeholder="Tvoje p≈ôezd√≠vka..." 
          maxlength="20"
          value="${this.state.playerNickname || ''}"
        />
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-primary" onclick="game.saveHighScoreToSheet()">
            üíæ Ulo≈æit do ≈æeb≈ô√≠ƒçku
          </button>
          <button class="modal-btn modal-btn-secondary" onclick="game.skipNickname()">
            P≈ôeskoƒçit
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Focus na input
    setTimeout(() => {
      document.getElementById('nickname-input').focus();
    }, 100);
    
    // Enter key = save
    document.getElementById('nickname-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        this.saveHighScoreToSheet();
      }
    });
  },

  saveHighScoreToSheet() {
    const nicknameInput = document.getElementById('nickname-input');
    const nickname = nicknameInput.value.trim() || 'Anonymous';
    
    // Ulo≈æ nickname do localStorage
    this.state.playerNickname = nickname;
    localStorage.setItem('doupe_nickname', nickname);
    
    // Ulo≈æ best run
    this.state.bestRun = this.state.day;
    localStorage.setItem('doupe_best_run', this.state.day.toString());
    
    // Ode≈°li do Google Sheets
    const data = {
      playerId: this.state.playerId,
      nickname: nickname,
      days: this.state.day,
      season: this.seasons[this.state.season].name,
      population: this.state.entities.length + 1,
      temperature: this.state.temperature,
      foodLeft: this.state.inventory.food || 0,
      waterLeft: this.state.inventory.water_supply || 0
    };
    
    // Zobraz loading
    nicknameInput.disabled = true;
    nicknameInput.value = 'Ukl√°d√°m...';
    
    this.backend('saveHighScore', data)
      .then((response) => {
        if (response.success) {
          console.log('High score saved:', response);
          this.closeModal('nickname-modal');
          this.showGameOverScreen(`üèÜ ${response.message}`);
        } else if (response.standalone) {
          // Standalone mode - save locally only
          console.log('Standalone mode - saved locally');
          this.closeModal('nickname-modal');
          this.showGameOverScreen('üíÄ GAME OVER (Local save)');
        } else {
          throw new Error(response.message || 'Unknown error');
        }
      })
      .catch((error) => {
        console.error('Error saving high score:', error);
        alert('Chyba p≈ôi ukl√°d√°n√≠: ' + (error.message || error));
        nicknameInput.disabled = false;
        nicknameInput.value = nickname;
      });
  },

  skipNickname() {
    // Ulo≈æ best run bez odesl√°n√≠ do sheets
    this.state.bestRun = this.state.day;
    localStorage.setItem('doupe_best_run', this.state.day.toString());
    
    this.closeModal('nickname-modal');
    this.showGameOverScreen('üíÄ GAME OVER');
  },

  showGameOverScreen(title) {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeIn 0.5s ease-out;
    `;
    overlay.innerHTML = `
      <div style="
        background: linear-gradient(145deg, #1a1410, #2d2416);
        padding: 50px;
        border-radius: 24px;
        text-align: center;
        border: 2px solid rgba(192, 80, 77, 0.5);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
        animation: scaleIn 0.5s ease-out 0.2s both;
      ">
        <h1 style="
          color: #e67e7b;
          font-size: 48px;
          margin-bottom: 20px;
          font-family: 'Space Mono', monospace;
          text-shadow: 0 4px 12px rgba(230, 126, 123, 0.5);
        ">${title}</h1>
        <p style="
          color: #9a8670;
          font-size: 16px;
          margin-bottom: 30px;
          font-family: 'Space Mono', monospace;
        ">P≈ôe≈æil jsi ${this.state.day} dn√≠</p>
        <button onclick="game.confirmReset()" style="
          padding: 16px 32px;
          font-size: 18px;
          background: linear-gradient(135deg, #8b5a2b, #a67c52);
          color: white;
          border: none;
          border-radius: 12px;
          cursor: pointer;
          font-family: 'Space Mono', monospace;
          font-weight: 700;
          box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        ">üîÑ Zkusit znovu</button>
      </div>
    `;
    
    document.body.appendChild(overlay);
  },

  showLeaderboard() {
    // Lock scroll
    this.openModal();
    
    // Zobraz loading
    const loadingModal = document.createElement('div');
    loadingModal.className = 'modal-overlay';
    loadingModal.id = 'leaderboard-modal';
    loadingModal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">üèÜ ≈ΩEB≈ò√çƒåEK</div>
        <p class="nickname-info">Naƒç√≠t√°m data...</p>
      </div>
    `;
    document.body.appendChild(loadingModal);
    
    // Naƒçti data z Sheets (p≈ôes API)
    this.backend('getLeaderboard')
      .then((response) => {
        if (response.success) {
          this.renderLeaderboard(response.data);
        } else {
          // API failed - show error or standalone
          console.error('Leaderboard load failed:', response);
          alert('Chyba p≈ôi naƒç√≠t√°n√≠ ≈æeb≈ô√≠ƒçku: ' + (response.message || response.error));
          this.closeModal('leaderboard-modal');
        }
      })
      .catch((error) => {
        console.error('Leaderboard error:', error);
        alert('Chyba p≈ôi naƒç√≠t√°n√≠ ≈æeb≈ô√≠ƒçku: ' + error.message);
        this.closeModal('leaderboard-modal');
      });
  },

  renderLeaderboard(data) {
    const modal = document.getElementById('leaderboard-modal');
    
    let tableRows = '';
    if (data.length === 0) {
      tableRows = '<tr><td colspan="4" style="text-align: center; padding: 30px; color: #9a8670;">≈Ωeb≈ô√≠ƒçek je zat√≠m pr√°zdn√Ω...</td></tr>';
    } else {
      tableRows = data.map(entry => {
        const rankClass = entry.rank <= 3 ? `rank-${entry.rank}` : 'rank-other';
        const isYou = entry.playerId === this.state.playerId;
        const rowClass = isYou ? 'your-rank' : '';
        
        return `
          <tr class="${rowClass}">
            <td><span class="rank-badge ${rankClass}">${entry.rank}</span></td>
            <td>${entry.nickname}${isYou ? ' <strong>(ty)</strong>' : ''}</td>
            <td><strong>${entry.days}d</strong></td>
            <td>${this.getSeasonIcon(entry.season)} ${entry.population}üë•</td>
          </tr>
        `;
      }).join('');
    }
    
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">üèÜ TOP 10 KOLONI√ç</div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Jm√©no</th>
              <th>Dny</th>
              <th>Info</th>
            </tr>
          </thead>
          <tbody>
            ${tableRows}
          </tbody>
        </table>
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('leaderboard-modal')">
            Zav≈ô√≠t
          </button>
        </div>
      </div>
    `;
  },

  getSeasonIcon(seasonName) {
    const icons = {
      'Jaro': 'üå±',
      'L√©to': '‚òÄÔ∏è',
      'Podzim': 'üçÇ',
      'Zima': '‚ùÑÔ∏è'
    };
    return icons[seasonName] || 'üåç';
  },

  // üíæ SAVE & LOAD GAME
  saveGame() {
    try {
      const saveData = JSON.stringify(this.state);
      
      // Save via backend (Apps Script) or localStorage (standalone)
      if (this.isAppsScript) {
        this.backend('saveGameState', saveData)
          .then((response) => {
            if (response.success) {
              this.log('üíæ ' + response.message, 'success');
              this.showNotification('üíæ Hra ulo≈æena!');
            } else {
              throw new Error(response.message);
            }
          })
          .catch((error) => {
            this.log('‚ùå Chyba p≈ôi ukl√°d√°n√≠: ' + error, 'danger');
          });
      } else {
        // Standalone - localStorage
        localStorage.setItem('doupe_save', saveData);
        this.log('üíæ Hra ulo≈æena (lok√°lnƒõ)', 'success');
        this.showNotification('üíæ Hra ulo≈æena!');
      }
      
      // GA Tracking
      this.track('game_saved', {
        day: this.state.day,
        season: this.seasons[this.state.season].name,
        population: this.state.entities.length + 1
      });
      
    } catch(e) {
      this.log('‚ùå Nepoda≈ôilo se ulo≈æit hru', 'danger');
      console.error('Save error:', e);
    }
  },

  /**
   * üìÇ LOAD GAME
   * 
   * Naƒçte ulo≈æenou hru a zobraz√≠ modal s preview (den, sez√≥na, z√°soby).
   * ‚ö†Ô∏è MUS√ç zobrazit modal - ne p≈ô√≠mo naƒç√≠st!
   * User m≈Ø≈æe potvrdit nebo zru≈°it naƒçten√≠.
   * 
   * @returns {void}
   * @fires game.openModal - Locks body scroll
   * @fires game.showLoadConfirmModal - Displays preview modal
   * @fires game.backend - In Apps Script mode
   * @sideeffects Adds modal to DOM, locks scroll
   * 
   * @example
   * game.loadGame(); // Zobraz√≠ modal s preview
   * 
   * @see confirmLoad() - Actual load happens here after confirmation
   * @tested ‚úÖ 2026-02-08 - Modal displays correctly
   */
  loadGame() {
    console.log('üîÑ loadGame() called');
    
    // Lock scroll
    this.openModal();
    console.log('‚úÖ Modal locked');
    
    // Show loading modal first
    const loadingModal = document.createElement('div');
    loadingModal.className = 'modal-overlay';
    loadingModal.id = 'load-modal';
    loadingModal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">üìÇ NAƒå√çST HRU</div>
        <p class="nickname-info">Naƒç√≠t√°m ulo≈æenou hru...</p>
      </div>
    `;
    document.body.appendChild(loadingModal);
    console.log('‚úÖ Loading modal added to DOM');
    
    // Load save data
    const loadSaveData = () => {
      if (this.isAppsScript) {
        console.log('üåê Apps Script mode - calling backend');
        return this.backend('loadGameState');
      } else {
        console.log('üíæ Standalone mode - checking localStorage');
        // Standalone - localStorage
        const saved = localStorage.getItem('doupe_save');
        if (saved) {
          console.log('‚úÖ Save found in localStorage');
          return Promise.resolve({ success: true, data: saved });
        } else {
          console.log('‚ùå No save in localStorage');
          return Promise.resolve({ success: false, message: '≈Ω√°dn√° ulo≈æen√° hra' });
        }
      }
    };
    
    loadSaveData()
      .then((response) => {
        console.log('üì¶ Response:', response);
        if (response.success && response.data) {
          const saveState = JSON.parse(response.data);
          console.log('‚úÖ Save state parsed:', saveState);
          this.showLoadConfirmModal(saveState);
        } else {
          // No save found
          console.log('‚ùå No save found - closing modal');
          this.closeModal('load-modal');
          this.log('‚ùå ≈Ω√°dn√° ulo≈æen√° hra nenalezena', 'warning');
          this.showNotification('‚ùå ≈Ω√°dn√° ulo≈æen√° hra');
        }
      })
      .catch((error) => {
        console.error('‚ùå Error loading save:', error);
        this.closeModal('load-modal');
        this.log('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠: ' + error, 'danger');
        alert('Chyba p≈ôi naƒç√≠t√°n√≠: ' + error.message);
      });
  },

  // üìÇ SHOW LOAD CONFIRM MODAL - zobraz√≠ preview save a potvrzen√≠
  showLoadConfirmModal(saveState) {
    const modal = document.getElementById('load-modal');
    
    if (!modal) {
      console.error('Load modal not found!');
      return;
    }
    
    // Bezpeƒçn√© naƒçten√≠ sez√≥ny
    const seasonIndex = saveState.season || 0;
    const season = this.seasons[seasonIndex] || this.seasons[0];
    const population = (saveState.entities?.length || 0) + 1;
    
    // Bezpeƒçn√Ω v√Ωpoƒçet dn√≠ (pokud drain je 0, nastav "‚àû")
    const hungerDrain = season.hungerDrain || 1;
    const waterDrain = season.waterDrain || 1;
    const foodDays = Math.floor((saveState.inventory?.food || 0) / hungerDrain);
    const waterDays = Math.floor((saveState.inventory?.water_supply || 0) / waterDrain);
    
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-title">üìÇ NAƒå√çST ULO≈ΩENOU HRU?</div>
        
        <div style="text-align: left; color: #b89968; line-height: 1.6; margin: 20px 0; background: rgba(20, 16, 12, 0.6); padding: 20px; border-radius: 12px; border: 1px solid rgba(139, 90, 43, 0.3);">
          <p style="margin-bottom: 12px; font-size: 16px; color: #d4a574;">
            <strong>üìä Informace o ulo≈æen√© h≈ôe:</strong>
          </p>
          
          <p style="margin-bottom: 8px;">
            üìÖ <strong>Den:</strong> ${saveState.day || 1} (${season.icon} ${season.name})
          </p>
          
          <p style="margin-bottom: 8px;">
            üë• <strong>Kolonie:</strong> ${population} obyvatel
          </p>
          
          <p style="margin-bottom: 8px;">
            üçñ <strong>J√≠dlo:</strong> ${saveState.inventory?.food || 0} (${foodDays}d)
          </p>
          
          <p style="margin-bottom: 8px;">
            üíß <strong>Voda:</strong> ${saveState.inventory?.water_supply || 0} (${waterDays}d)
          </p>
          
          <p style="margin-bottom: 8px;">
            üå°Ô∏è <strong>Teplota:</strong> ${saveState.temperature || 15}¬∞C
          </p>
          
          <p style="margin-bottom: 8px;">
            üí∞ <strong>Zlato:</strong> ${saveState.gold || 0}g
          </p>
          
          ${saveState.fireActive ? '<p style="margin-bottom: 8px; color: #ff9944;">üî• <strong>Ohe≈à ho≈ô√≠!</strong></p>' : ''}
        </div>
        
        <p class="nickname-info" style="color: #e67e7b; font-size: 13px; margin-top: -10px;">
          ‚ö†Ô∏è Souƒçasn√Ω postup bude ztracen!
        </p>
        
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-primary" onclick="game.confirmLoad()">
            ‚úÖ Naƒç√≠st tuto hru
          </button>
          <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('load-modal')">
            ‚ùå Zru≈°it
          </button>
        </div>
      </div>
    `;
    
    // Store save state for confirmLoad
    this._pendingSaveState = saveState;
  },

  // ‚úÖ CONFIRM LOAD - potvrzen√≠ a naƒçten√≠ hry
  confirmLoad() {
    if (!this._pendingSaveState) return;
    
    try {
      // Load the saved state
      this.state = this._pendingSaveState;
      delete this._pendingSaveState;
      
      // Close modal
      this.closeModal('load-modal');
      
      // Success feedback
      this.log('üìÇ Hra √∫spƒõ≈°nƒõ naƒçtena!', 'success');
      this.showNotification('üìÇ Hra naƒçtena!');
      
      // GA Tracking
      this.track('game_loaded', {
        day: this.state.day,
        season: this.seasons[this.state.season].name,
        population: this.state.entities.length + 1
      });
      
      // üéµ AUTO-START MUSIC after loading game
      if (window.atmosphericMusic && !window.atmosphericMusic.isPlaying) {
        const audioMuted = localStorage.getItem('allAudioMuted') === 'true';
        if (!audioMuted) {
          console.log('üéµ Auto-starting music after Load Game');
          window.atmosphericMusic.play(this.state.season, true); // forceFirstTrack = true
        }
      }
      
      // üî• AUTO-START FIRE CRACKLE if fire is active
      if (window.fireCrackle && this.state.fireActive && !window.fireCrackle.isPlaying) {
        const audioMuted = localStorage.getItem('allAudioMuted') === 'true';
        if (!audioMuted) {
          console.log('üî• Auto-starting fire crackle after Load Game');
          window.fireCrackle.start();
        }
      }
      
      // Re-render everything
      this.render();
      
    } catch(e) {
      this.closeModal('load-modal');
      this.log('‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ hry', 'danger');
      console.error('Load error:', e);
    }
  },

  reset() {
    // If player is alive (not in game over), show warning modal
    if (!this.state.dead) {
      this.showResetWarningModal();
      return;
    }
    
    // If dead, reset immediately (from game over screen)
    this.confirmReset();
  },

  // ‚ö†Ô∏è RESET WARNING MODAL - zobraz√≠ p≈ôed resetem ≈æiv√© hry
  showResetWarningModal() {
    // Lock scroll
    this.openModal();
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'reset-warning-modal';
    
    // Calculate current stats
    const season = this.seasons[this.state.season];
    const population = this.state.entities.length + 1;
    const foodLeft = this.state.inventory.food || 0;
    const waterLeft = this.state.inventory.water_supply || 0;
    const goldLeft = this.state.gold || 0;
    
    // Days remaining calculation
    const hungerDrain = season.hungerDrain || 1;
    const waterDrain = season.waterDrain || 1;
    const foodDays = Math.floor(foodLeft / hungerDrain);
    const waterDays = Math.floor(waterLeft / waterDrain);
    const survivalDays = Math.min(foodDays, waterDays);
    
    // Count valuable items
    const storage = this.state.inventory.storage || 0;
    const fireplace = this.state.inventory.fireplace || 0;
    const insulation = this.state.inventory.insulation || 0;
    const wall = this.state.inventory.wall || 0;
    const hasInfrastructure = storage > 0 || fireplace > 0 || insulation > 0 || wall > 0;
    
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 600px;">
        <div class="modal-title" style="color: #e67e7b;">‚ö†Ô∏è OPRAVDU CHCE≈† ZAƒå√çT ZNOVU?</div>
        
        <div style="text-align: left; color: #b89968; line-height: 1.8; margin: 25px 0;">
          
          <!-- Main Warning Message -->
          <div style="background: rgba(192, 80, 77, 0.15); padding: 20px; border-radius: 12px; border: 2px solid rgba(192, 80, 77, 0.4); margin-bottom: 20px;">
            <p style="font-size: 16px; font-weight: 700; color: #e67e7b; margin-bottom: 12px;">
              ‚ö†Ô∏è Kolonie st√°le z√°vis√≠ na tv√©m ≈æivotƒõ!
            </p>
            <p style="font-size: 14px; color: #d4a574; margin-bottom: 8px;">
              üìç Postupuj ve h≈ôe tlaƒç√≠tkem <strong>Next Day</strong>. P≈ôeci si nep≈ôejete zaƒç√≠nat zcela znovu.
            </p>
            <p style="font-size: 14px; color: #d4a574;">
              üíæ Nezapome≈àte si <strong>ukl√°dat hru p≈ôi hran√≠</strong> - v√°≈° pokrok je cenn√Ω!
            </p>
          </div>

          <!-- Current Stats -->
          <div style="background: rgba(20, 16, 12, 0.6); padding: 20px; border-radius: 12px; border: 1px solid rgba(139, 90, 43, 0.3); margin-bottom: 20px;">
            <p style="font-size: 15px; font-weight: 700; color: #d4a574; margin-bottom: 15px;">
              üìä CO ZTRAT√ç≈† RESETEM:
            </p>
            
            <div style="display: grid; gap: 10px; font-size: 13px;">
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üìÖ P≈ôe≈æit√© dny:</span>
                <strong style="color: #d4a574;">${this.state.day} dn√≠</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>${season.icon} Sez√≥na:</span>
                <strong style="color: #d4a574;">${season.name}</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üë• Populace:</span>
                <strong style="color: #d4a574;">${population} obyvatel</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üçñ J√≠dlo:</span>
                <strong style="color: ${foodLeft < 20 ? '#e67e7b' : '#7bc876'};">${foodLeft} (${foodDays}d)</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üíß Voda:</span>
                <strong style="color: ${waterLeft < 20 ? '#e67e7b' : '#7bc876'};">${waterLeft} (${waterDays}d)</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üü° Zlato:</span>
                <strong style="color: #f4d03f;">${goldLeft}g</strong>
              </div>
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üå°Ô∏è Teplota:</span>
                <strong style="color: ${this.state.temperature < 10 ? '#7bc9ff' : this.state.temperature > 23 ? '#e67e7b' : '#7bc876'};">${this.state.temperature}¬∞C</strong>
              </div>
              
              ${hasInfrastructure ? `
              <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">
                <span>üèóÔ∏è Infrastruktura:</span>
                <strong style="color: #d4a574;">
                  ${storage > 0 ? 'üì¶ ' : ''}${fireplace > 0 ? 'üî• ' : ''}${insulation > 0 ? 'üß± ' : ''}${wall > 0 ? 'üõ°Ô∏è ' : ''}
                </strong>
              </div>
              ` : ''}
              
              <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                <span>‚è∞ P≈ôe≈æije≈° je≈°tƒõ:</span>
                <strong style="color: ${survivalDays < 5 ? '#e67e7b' : survivalDays < 15 ? '#f4d03f' : '#7bc876'};">
                  ~${survivalDays} dn√≠
                </strong>
              </div>
            </div>
          </div>

          <!-- Final Warning -->
          <div style="text-align: center; padding: 15px; background: rgba(192, 80, 77, 0.1); border-radius: 8px; border: 1px solid rgba(192, 80, 77, 0.3);">
            <p style="font-size: 13px; color: #e67e7b; font-weight: 700;">
              üíÄ Resetem zniƒç√≠≈° cel√Ω tento svƒõt a zaƒçne≈° od zaƒç√°tku!
            </p>
          </div>
        </div>
        
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('reset-warning-modal')">
            ‚úã Zru≈°it - Pokraƒçovat ve h≈ôe
          </button>
          <button class="modal-btn modal-btn-danger" onclick="game.confirmReset()" style="background: linear-gradient(135deg, #c0504d, #e67e7b); border-color: rgba(230, 126, 123, 0.5);">
            üíÄ Opravdu Resetovat
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
  },

  // üîÑ CONFIRM RESET - samotn√Ω reset po potvrzen√≠
  confirmReset() {
    // Close any modals
    this.closeModal('reset-warning-modal');
    
    // Odstra≈à game over overlay pokud existuje
    const overlay = document.querySelector('div[style*="position: fixed"]');
    if (overlay) overlay.remove();
    
    // Odstra≈à modals
    const modal = document.getElementById('leaderboard-modal') || document.getElementById('nickname-modal');
    if (modal) modal.remove();

    // GA Tracking - Game Reset
    const wasDead = this.state.dead;
    const finalDay = this.state.day;
    
    this.track('game_reset', {
      was_dead: wasDead,
      previous_days: finalDay,
      reset_type: wasDead ? 'after_death' : 'manual_restart'
    });
    
    // Zachovej player data
    const savedPlayerId = this.state.playerId;
    const savedNickname = this.state.playerNickname;
    const savedBestRun = this.state.bestRun;

    this.state = {
      day: 1,
      season: 0,
      dead: false,
      inventory: {},
      entities: [],
      unlockedRecipes: [],
      eventChance: 0.5,
      temperature: 15,
      shelterLevel: 1,
      heating: 0,
      guaranteedStones: 0,
      playerId: savedPlayerId,
      playerNickname: savedNickname,
      bestRun: savedBestRun,
      fireActive: false,
      fireFuel: 0,
      gold: 0,
      weatherMode: 'game',
      weatherData: null,
      lastWeatherFetch: 0
    };

    document.getElementById('log').innerHTML = '';
    this.init();
  },

  renderInventory() {
    const el = document.getElementById('inventory');
    el.innerHTML = '';
	
	// üõí FIX: ALWAYS show buyable items even if count = 0
	const inventory = { ...this.state.inventory };
		if (!inventory.food && this.items.food) inventory.food = 0;
		if (!inventory.water_supply && this.items.water_supply) inventory.water_supply = 0;

    const entries = Object.entries(inventory ?? {});

    if (entries.length === 0) {
      el.innerHTML = '<div class="empty-state">Invent√°≈ô je pr√°zdn√Ω...</div>';
      return;
    }

    entries.forEach(([id, count]) => {
      const item = this.items[id];
      if (!item) return;

      const card = document.createElement('div');
      card.className = 'item-card';
      
      // üí∞ ECONOMY: Sell button (pro v≈°echno kromƒõ food/water)
      let actionButton = '';
      if (item.sellPrice && id !== 'food' && id !== 'water_supply') {
        actionButton = `
          <button class="item-action-btn item-sell-btn" onclick="game.sellItem('${id}', 1)">
            üü° ${item.sellPrice}g
          </button>
        `;
      }
      
      // üí∞ ECONOMY: Buy button (jen pro food/water)
      if (item.buyPrice && (id === 'food' || id === 'water_supply')) {
        actionButton = `
          <button class="item-action-btn item-buy-btn" onclick="game.buyItem('${id}', 1)">
            üè∑Ô∏è ${item.buyPrice}g
          </button>
        `;
      }
      
      card.innerHTML = `
        <div class="item-icon">${item.icon}</div>
        <div class="item-details">
          <div class="item-name">${item.name}</div>
          <div class="item-desc">${item.desc}</div>
        </div>
        <div class="item-count">√ó${count}</div>
        ${actionButton}
      `;

      el.appendChild(card);
    });
  },

  renderRecipes() {
    const el = document.getElementById('recipes');
    el.innerHTML = '';

    // Zobraz jen odemƒçen√© recepty
    const availableRecipes = this.recipes.filter(r => {
      // Skip fire starters if fire is already active
      if (r.isFireStarter && this.state.fireActive) {
        return false;
      }
      return this.state.unlockedRecipes.includes(r.id);
    });

    if (availableRecipes.length === 0) {
      el.innerHTML = '<div class="empty-state">Zat√≠m ≈æ√°dn√© recepty...</div>';
      return;
    }

    availableRecipes.forEach(recipe => {
      const canCraft = this.hasMaterials(recipe.materials) && 
                       this.hasTools(recipe.requires);

      const card = document.createElement('div');
      card.className = `recipe-card ${canCraft ? 'can-craft' : 'cannot-craft'}`;

      const mats = Object.entries(recipe.materials)
        .map(([id, needed]) => {
          const have = this.state.inventory[id] || 0;
          const item = this.items[id];
          return `${item.icon} ${have}/${needed}`;
        })
        .join(' ‚Ä¢ ');

      let requiresText = '';
      if (recipe.requires) {
        requiresText = ' | Vy≈æaduje: ' + Object.keys(recipe.requires)
          .map(id => this.items[id].icon)
          .join(' ');
      }

      card.innerHTML = `
        <div class="recipe-header">
          <div class="recipe-icon">${recipe.icon}</div>
          <div class="recipe-name">${recipe.name}</div>
        </div>
        <div class="recipe-materials">${mats}${requiresText}</div>
      `;

      if (canCraft) {
        card.onclick = () => this.craft(recipe.id);
      }

      el.appendChild(card);
    });
  },

  renderEntities() {
    const section = document.getElementById('entities-section');
    const el = document.getElementById('entities');

    if (this.state.entities.length === 0) {
      section.style.display = 'none';
      return;
    }

    section.style.display = 'block';
    el.innerHTML = '';

    this.state.entities.forEach(entity => {
      const type = this.entityTypes.find(t => t.id === entity.type);
      
      const card = document.createElement('div');
      card.className = 'entity-card';

      let statusText = 'Neƒçinn√Ω';
      if (entity.status === 'working') {
        statusText = `${entity.action.name} (${entity.daysLeft} dn√≠)`;
      }

      card.innerHTML = `
        <div class="entity-header">
          <div class="entity-icon">${entity.icon}</div>
          <div class="entity-info">
            <div class="entity-name">${entity.name}</div>
            <div class="entity-status">${statusText}</div>
          </div>
        </div>
      `;

      if (entity.status === 'idle') {
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'entity-actions';

        type.actions.forEach((action, index) => {
          const canDo = this.hasTools(action.requires);
          const btn = document.createElement('button');
          btn.className = 'entity-action-btn';
          btn.textContent = action.name;
          btn.disabled = !canDo;
          btn.onclick = () => this.assignAction(entity.id, index);
          actionsDiv.appendChild(btn);
        });

        card.appendChild(actionsDiv);
      }

      el.appendChild(card);
    });
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ö†Ô∏è CRITICAL FUNCTION - MAIN RENDER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  /**
   * üé® RENDER GAME
   * 
   * Aktualizuje cel√© UI podle aktu√°ln√≠ho stavu (this.state).
   * Vol√° v≈°echny sub-render funkce (renderInventory, renderRecipes, atd.).
   * 
   * ‚ö†Ô∏è MUS√ç b√Ωt vol√°no po ka≈æd√© zmƒõnƒõ stavu!
   * 
   * @returns {void}
   * @fires renderInventory() - Updates inventory display
   * @fires renderRecipes() - Updates recipe cards
   * @fires renderEntities() - Updates entities section
   * @fires updateFireIndicator() - Updates fire status
   * @fires updateFooterStats() - Updates footer statistics
   * @fires autoUnlockRecipes() - Checks for new recipes to unlock
   * @sideeffects Updates entire DOM based on game state
   * 
   * @example
   * game.state.day++;
   * game.render(); // Update UI
   * 
   * @tested ‚úÖ 2026-02-08 - All sections update correctly
   */
  render() {
    document.getElementById('day').textContent = this.state.day;
    const season = this.seasons[this.state.season];
    document.getElementById('season').textContent = season.name;

    // Population multiplier + temperature effects pro consumption
    const effectivePopulation = Math.max(0, this.state.entities.length - 1);
    const populationMultiplier = 1 + (effectivePopulation * 0.4);
    const tempEffects = this.getTemperatureEffects();

    // Zobraz√≠me kolik m√°≈° vs. kolik pot≈ôebuje≈° na dal≈°√≠ den
    const hungerNeeded = Math.ceil(season.hungerDrain * populationMultiplier * tempEffects.hungerMultiplier);
    const waterNeeded = Math.ceil(season.waterDrain * populationMultiplier * tempEffects.waterMultiplier);
    
    const foodHave = this.state.inventory.food || 0;
    const waterHave = this.state.inventory.water_supply || 0;
    
    // Vypoƒç√≠tej kolik dn√≠ ti to vydr≈æ√≠
    const foodDays = hungerNeeded > 0 ? Math.floor(foodHave / hungerNeeded) : 0;
    const waterDays = waterNeeded > 0 ? Math.floor(waterHave / waterNeeded) : 0;
    
    // Bar ukazuje kolik dn√≠ ti to vydr≈æ√≠ (max 20 dn√≠ = 100%)
    const hungerPercent = Math.min(100, (foodDays / 20) * 100);
    const waterPercent = Math.min(100, (waterDays / 20) * 100);

    document.getElementById('hunger-fill').style.width = hungerPercent + '%';
    document.getElementById('hunger-fill').textContent = `${foodHave} (${foodDays}d)`;

    document.getElementById('water-fill').style.width = waterPercent + '%';
    document.getElementById('water-fill').textContent = `${waterHave} (${waterDays}d)`;

    // Temperature bar
    const temp = this.state.temperature;
    const tempEmoji = this.getTemperatureEmoji(temp);
    document.getElementById('temp-emoji').textContent = tempEmoji;
    
    // Temperature bar width: -10¬∞C = 0%, +40¬∞C = 100% (range 50¬∞C)
    const tempPercent = Math.max(0, Math.min(100, ((temp + 10) / 50) * 100));
    document.getElementById('temp-fill').style.width = tempPercent + '%';
    
    let tempText = `${temp}¬∞C`;
    if (this.state.heating > 0) {
      tempText += ` üî•√ó${this.state.heating}`;
    }
    if (this.state.shelterLevel > 1) {
      tempText += ` üß±√ó${Math.round((this.state.shelterLevel - 1) * 2)}`;
    }
    document.getElementById('temp-fill').textContent = tempText;

    this.renderInventory();
    this.renderRecipes();
    this.renderEntities();

    // Auto-unlock recept≈Ø podle invent√°≈ôe
    this.autoUnlockRecipes();
    // üî• Update fire indicator
    this.updateFireIndicator();
    // üí∞ Update gold display
    document.getElementById('gold-amount').textContent = this.state.gold;
    
    // üìä Update footer stats
    this.updateFooterStats();
  },

  autoUnlockRecipes() {
    let unlocked = false;
    
    this.recipes.forEach(recipe => {
      if (this.state.unlockedRecipes.includes(recipe.id)) return;
      
      // Zkontroluj jestli m√°≈° materi√°ly na tento recept
      const hasSomeMaterials = Object.keys(recipe.materials).some(
        matId => (this.state.inventory[matId] || 0) > 0
      );

      // Tier 1-2: unlock kdy≈æ m√°≈° materi√°ly
      if (hasSomeMaterials && recipe.tier <= 2) {
        this.state.unlockedRecipes.push(recipe.id);
        unlocked = true;
      }

      // Tier 3+: unlock kdy≈æ m√°≈° required tools
      if (recipe.tier >= 3 && recipe.requires) {
        if (this.hasTools(recipe.requires)) {
          this.state.unlockedRecipes.push(recipe.id);
          unlocked = true;
        }
      }
      
      // Tier 3+ BEZ requires: unlock kdy≈æ m√°≈° materi√°ly (luk, fireplace, insulation)
      if (recipe.tier >= 3 && !recipe.requires && hasSomeMaterials) {
        this.state.unlockedRecipes.push(recipe.id);
        unlocked = true;
      }
    });

    if (unlocked) {
      this.renderRecipes();
    }
  },
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé≤ THREAT TRIGGER SYSTEM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // Add to state in init():
  state: {
    // ... existing state
    lastSeasonalThreat: 0,
    randomThreatCount: 0,
    maxRandomThreats: 3, // nastaviteln√©
    threatCooldown: 3, // min 3 dny mezi hrozbami
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéØ CHECK THREATS (volat v nextDay())
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  checkThreats() {
    const daysSinceLastThreat = this.state.day - (this.state.lastSeasonalThreat || 0);

    // Cooldown check
    if (daysSinceLastThreat < this.state.threatCooldown) {
      return;
    }

    // üèÅ Konec obdob√≠ = garantovan√Ω seasonal threat
    if (this.state.day % 15 === 0 && this.state.day > 0) {
      this.triggerSeasonalThreat();
      return;
    }

    // üé≤ Random threat (pouze od 5. dne)
    if (this.state.day >= 5 && this.state.randomThreatCount < this.state.maxRandomThreats) {
      const chance = 0.10; // 10% per day
      if (Math.random() < chance) {
        this.triggerRandomThreat();
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üåç SEASONAL THREAT (konec obdob√≠)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  triggerSeasonalThreat() {
    const currentSeason = this.state.season;

    // Filter threats by season
    const seasonalThreats = Object.values(this.threats).filter(t => 
      t.seasons && t.seasons.includes(currentSeason)
    );

    if (seasonalThreats.length === 0) {
      // Fallback to any threat
      const allThreats = Object.values(this.threats).filter(t => t.seasons);
      if (allThreats.length > 0) {
        const threat = allThreats[Math.floor(Math.random() * allThreats.length)];
        this.triggerThreat(threat, true);
      }
      return;
    }

    // Weighted random (tier = weight)
    const totalWeight = seasonalThreats.reduce((sum, t) => sum + t.tier, 0);
    let roll = Math.random() * totalWeight;

    for (const threat of seasonalThreats) {
      roll -= threat.tier;
      if (roll <= 0) {
        this.triggerThreat(threat, true);
        return;
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé≤ RANDOM THREAT (kdykoliv)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  triggerRandomThreat() {
    const allThreats = Object.values(this.threats);
    const threat = allThreats[Math.floor(Math.random() * allThreats.length)];

    this.triggerThreat(threat, false);
    this.state.randomThreatCount++;
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚öîÔ∏è TRIGGER THREAT (main)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  triggerThreat(threat, isSeasonal) {
    this.state.lastSeasonalThreat = this.state.day;

    // Check if can avoid (medicine_hut for plague)
    if (threat.canAvoid) {
      const canAvoid = Object.entries(threat.canAvoid).every(([item, count]) => 
        (this.state.inventory[item] || 0) >= count
      );

      if (canAvoid) {
        this.log(threat.avoidMessage, 'success');
        this.showNotification('üíä Hrozba odvr√°cena!');

        // GA4 tracking
        this.track('threat_avoided', {
          threat_id: threat.id,
          threat_name: threat.name,
          day: this.state.day
        });

        return;
      }
    }

    // Store threat for later use in mode selection
    this.pendingThreat = threat;

    // Show combat mode selection modal
    this.showCombatModeSelectionModal(threat);

    // GA4 tracking
    this.track('threat_triggered', {
      threat_id: threat.id,
      threat_name: threat.name,
      threat_tier: threat.tier,
      is_seasonal: isSeasonal,
      day: this.state.day
    });
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé® COMBAT UI - Modal & Rendering
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéÆ SHOW COMBAT MODE SELECTION MODAL
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  showCombatModeSelectionModal(threat) {
    this.openModal();

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'combat-mode-selection-modal';

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 700px;">
        <div class="modal-title" style="color: #e67e7b;">‚öîÔ∏è ZVOLTE TYP SOUBOJE</div>
        
        <div style="margin: 20px 0; color: #b89968; text-align: center; font-size: 14px;">
          Mus√≠te ƒçelit: <strong style="color: #e67e7b;">${threat.name}</strong>
        </div>
        
        <div style="display: grid; gap: 20px; margin: 30px 0;">
          
          <!-- M√≥d A: Pi≈°kvorky -->
          <div class="combat-mode-card" onclick="game.selectCombatMode('tictactoe')" style="
            background: linear-gradient(135deg, rgba(78, 201, 176, 0.1), rgba(78, 201, 176, 0.05));
            border: 2px solid rgba(78, 201, 176, 0.3);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
          " onmouseover="this.style.borderColor='rgba(78, 201, 176, 0.6)'" onmouseout="this.style.borderColor='rgba(78, 201, 176, 0.3)'">
            <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">üéØ</div>
            <div style="font-size: 20px; font-weight: 700; color: #4ec9b0; text-align: center; margin-bottom: 8px;">
              Pi≈°kvorky
            </div>
            <div style="color: #b89968; text-align: center; font-size: 14px; line-height: 1.6; margin-bottom: 12px;">
              Klasick√° strategick√° hra. Udƒõlej 5 v ≈ôadƒõ d≈ô√≠ve ne≈æ nep≈ô√≠tel.
            </div>
            <div style="text-align: center; color: #8b7355; font-size: 12px;">
              ‚≠ê Strategie ‚Ä¢ 5-10 min
            </div>
          </div>
          
          <!-- M√≥d B: Go -->
          <div class="combat-mode-card" onclick="game.selectCombatMode('go')" style="
            background: linear-gradient(135deg, rgba(156, 220, 254, 0.1), rgba(156, 220, 254, 0.05));
            border: 2px solid rgba(156, 220, 254, 0.3);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
          " onmouseover="this.style.borderColor='rgba(156, 220, 254, 0.6)'" onmouseout="this.style.borderColor='rgba(156, 220, 254, 0.3)'">
            <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">‚ö´‚ö™</div>
            <div style="font-size: 20px; font-weight: 700; color: #9cdcfe; text-align: center; margin-bottom: 8px;">
              Go (zjednodu≈°en√©)
            </div>
            <div style="color: #b89968; text-align: center; font-size: 14px; line-height: 1.6; margin-bottom: 12px;">
              Ovl√°dni √∫zem√≠. Obklop nep≈ô√°telsk√© kameny a z√≠skej body.
            </div>
            <div style="text-align: center; color: #8b7355; font-size: 12px;">
              ‚≠ê‚≠ê Taktika ‚Ä¢ 7-15 min
            </div>
          </div>
          
          <!-- M√≥d C: D&D Rolls -->
          <div class="combat-mode-card" onclick="game.selectCombatMode('dnd')" style="
            background: linear-gradient(135deg, rgba(206, 145, 120, 0.1), rgba(206, 145, 120, 0.05));
            border: 2px solid rgba(206, 145, 120, 0.3);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
          " onmouseover="this.style.borderColor='rgba(206, 145, 120, 0.6)'" onmouseout="this.style.borderColor='rgba(206, 145, 120, 0.3)'">
            <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">üé≤</div>
            <div style="font-size: 20px; font-weight: 700; color: #ce9178; text-align: center; margin-bottom: 8px;">
              D&D Kostky
            </div>
            <div style="color: #b89968; text-align: center; font-size: 14px; line-height: 1.6; margin-bottom: 8px;">
              Rychl√Ω boj na HP. Hod kostkou a √∫toƒçƒè a≈æ do posledn√≠ho dechu!
            </div>
            <div style="background: rgba(78, 201, 176, 0.15); padding: 8px; border-radius: 6px; margin-bottom: 12px;">
              <div style="color: #4ec9b0; text-align: center; font-size: 13px; font-weight: 600;">
                ‚ú® J√≠dlo se NEMA≈ΩE! HP je jen virtu√°ln√≠ boj
              </div>
            </div>
            <div style="text-align: center; color: #8b7355; font-size: 12px;">
              ‚≠ê Rychl√Ω ‚Ä¢ ≈†tƒõst√≠ ‚Ä¢ 2-5 min
            </div>
          </div>
          
        </div>
        
        <div style="text-align: center; color: #8b7355; font-size: 13px; margin-top: 20px;">
          üí° Tip: D&D kostky jsou nejrychlej≈°√≠, Go nejtƒõ≈æ≈°√≠
        </div>
      </div>
    `;

    document.body.appendChild(modal);
  },

  selectCombatMode(gameType) {
    // Close mode selection modal
    this.closeModal('combat-mode-selection-modal');
    
    // Get current threat (stored when modal was opened)
    const threat = this.combat.currentThreat || this.pendingThreat;
    
    // Show appropriate combat modal based on selected mode
    this.showCombatModal(threat, gameType);
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìã SHOW COMBAT MODAL
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  showCombatModal(threat, gameType = 'tictactoe') {
    this.openModal();

    // Init combat system with selected game type
    this.combat.init(threat, gameType);

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'combat-modal';

    const seasonName = this.seasons[this.state.season].name;

    // Game type labels
    const gameTypeLabels = {
      tictactoe: 'üéØ Pi≈°kvorky',
      go: '‚ö´‚ö™ Go',
      dnd: 'üé≤ D&D Kostky'
    };
    const gameTypeLabel = gameTypeLabels[gameType] || 'üéØ Pi≈°kvorky';

    // Check if game type is implemented
    const isImplemented = gameType === 'tictactoe' || gameType === 'dnd' || gameType === 'go';

    modal.innerHTML = `
      <div class="modal-content" style="max-width: 600px;">
        <div style="text-align: center; margin-bottom: 20px;">
          <div style="font-size: 48px; margin-bottom: 10px;">${threat.icon}</div>
          <h2 style="color: #e74c3c; font-size: 24px; margin-bottom: 10px;">
            ${threat.name}
          </h2>
          <p style="color: #b89968; font-size: 20px; line-height: 1.6;">
            ${threat.intro}
          </p>
          <div style="margin-top: 10px; padding: 14px; background: rgba(231, 76, 60, 0.1); border-radius: 4px;">
            <span style="color: #e8d5b7; font-size: 12px;">
              ${seasonName} | Den ${this.state.day} | Obt√≠≈ænost: ${threat.aiDifficulty.toUpperCase()}
            </span>
            <br>
            <span style="color: #4ec9b0; font-size: 12px; font-weight: 600; margin-top: 4px; display: inline-block;">
              Typ: ${gameTypeLabel}
            </span>
          </div>
        </div>

        ${gameType === 'tictactoe' ? `
          <div id="combat-board-container" style="margin: 20px 0; text-align: center;">
            ${this.renderCombatBoardHTML()}
          </div>

          <div id="combat-status" style="text-align: center; margin: 18px 0; color: #4ec9b0; font-size: 14px; font-weight: 600;">
            Tv≈Øj tah: ${threat.playerIcon}
          </div>
        ` : gameType === 'go' ? `
          <!-- Go Combat UI -->
          <div style="margin: 20px 0;">
            <!-- Go Status -->
            <div style="display: flex; justify-content: space-between; margin-bottom: 15px; padding: 12px; background: rgba(20, 16, 12, 0.4); border-radius: 8px;">
              <div id="go-captured" style="color: #b89968; font-size: 13px;">
                ‚ö™ Zajato: ${this.combat.capturedStones.player} | ‚ö´ Zajato: ${this.combat.capturedStones.enemy}
              </div>
              <div id="go-turns" style="color: #9cdcfe; font-size: 13px; font-weight: 600;">
                Zb√Ωv√° tah≈Ø: ${this.combat.maxTurns - this.combat.currentTurn}
              </div>
            </div>

            <!-- Go Board -->
            <div id="combat-board-container" style="margin: 20px 0; text-align: center;">
              ${this.renderCombatBoardHTML()}
            </div>

            <!-- Go Control Status -->
            <div id="combat-status" style="text-align: center; margin: 15px 0; color: #4ec9b0; font-size: 14px; font-weight: 600;">
              Tv≈Øj tah: ‚ö™
            </div>

            <!-- Pass Button -->
            <div style="text-align: center; margin: 15px 0;">
              <button class="modal-btn modal-btn-secondary" onclick="game.handleGoPass()" style="padding: 10px 30px;">
                üîÑ Pasovat
              </button>
            </div>
          </div>
        ` : gameType === 'dnd' ? `
          <!-- D&D Combat UI -->
          <div style="margin: 20px 0;">
            <!-- Player HP Bar -->
            <div style="margin-bottom: 15px;">
              <div id="player-hp-text" style="color: #4ec9b0; font-size: 14px; font-weight: 600; margin-bottom: 6px;">
                üßô Ty: ${this.combat.playerHP}/${this.combat.playerMaxHP} HP
              </div>
              <div style="width: 100%; height: 24px; background: rgba(20, 16, 12, 0.6); border: 2px solid rgba(78, 201, 176, 0.3); border-radius: 12px; overflow: hidden;">
                <div id="player-hp-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #4ec9b0, #5dd5bd); transition: width 0.5s ease;"></div>
              </div>
            </div>

            <!-- Enemy HP Bar -->
            <div style="margin-bottom: 20px;">
              <div id="enemy-hp-text" style="color: #e67e7b; font-size: 14px; font-weight: 600; margin-bottom: 6px;">
                ${threat.icon} ${threat.name}: ${this.combat.enemyHP}/${this.combat.enemyMaxHP} HP
              </div>
              <div style="width: 100%; height: 24px; background: rgba(20, 16, 12, 0.6); border: 2px solid rgba(230, 126, 123, 0.3); border-radius: 12px; overflow: hidden;">
                <div id="enemy-hp-bar" style="width: 100%; height: 100%; background: linear-gradient(90deg, #e67e7b, #ef9a9a); transition: width 0.5s ease;"></div>
              </div>
            </div>

            <!-- Attack Button -->
            <div style="text-align: center; margin: 25px 0;">
              <button id="dnd-attack-btn" class="modal-btn modal-btn-primary" onclick="game.handleDndAttack()" style="
                font-size: 18px;
                padding: 15px 40px;
                background: linear-gradient(135deg, #4ec9b0, #5dd5bd);
                border: 2px solid rgba(78, 201, 176, 0.5);
                box-shadow: 0 4px 12px rgba(78, 201, 176, 0.3);
              ">
                ‚öîÔ∏è √öTOK!
              </button>
            </div>

            <!-- Combat Log -->
            <div style="margin-top: 20px; padding: 15px; background: rgba(20, 16, 12, 0.3); border-radius: 8px; border: 1px solid rgba(139, 90, 43, 0.2);">
              <div style="color: #d4a574; font-size: 13px; font-weight: 600; margin-bottom: 10px;">
                üìú Bojov√Ω log:
              </div>
              <div id="dnd-combat-log" style="max-height: 150px; overflow-y: auto; color: #b89968; font-size: 13px;">
                ${this.combat.combatLog.slice(-5).map(entry => 
                  `<div style="padding: 6px 10px; margin: 4px 0; background: rgba(20, 16, 12, 0.4); border-radius: 4px;">${entry}</div>`
                ).join('')}
              </div>
            </div>
          </div>
        ` : `
          <div style="text-align: center; margin: 40px 0; padding: 30px; background: rgba(206, 145, 120, 0.1); border: 2px dashed rgba(206, 145, 120, 0.3); border-radius: 12px;">
            <div style="font-size: 64px; margin-bottom: 15px;">üöß</div>
            <div style="color: #ce9178; font-size: 18px; font-weight: 600; margin-bottom: 10px;">
              ${gameTypeLabel} - Brzy dostupn√©!
            </div>
            <div style="color: #b89968; font-size: 14px; line-height: 1.6;">
              Tento hern√≠ m√≥d je ve v√Ωvoji.<br>
              Pro nyn√≠ pou≈æij Pi≈°kvorky.
            </div>
          </div>
        `}

        <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
          ${isImplemented ? `
            <button class="modal-btn modal-btn-secondary" onclick="game.fleeCombat()" style="flex: 1; max-width: 200px;">
              üèÉ Ut√©ct (50% ztr√°t)
            </button>
          ` : `
            <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('combat-modal'); game.showCombatModeSelectionModal(game.pendingThreat)" style="flex: 1; max-width: 250px;">
              ‚Üê Zpƒõt na v√Ωbƒõr
            </button>
            <button class="modal-btn modal-btn-danger" onclick="game.closeModal('combat-modal'); game.handleCombatEnd(false)" style="flex: 1; max-width: 200px;">
              üíÄ Vzd√°t se (penalizace)
            </button>
          `}
        </div>

        ${gameType === 'tictactoe' ? `
          <div style="margin-top: 15px; padding: 10px; background: rgba(20, 16, 12, 0.3); border-radius: 4px; font-size: 12px; color: #9ca3af;">
            <strong style="color: #e8d5b7;">Pravidla:</strong> Sestav 5 symbol≈Ø v ≈ôadƒõ (vodorovnƒõ, svisle nebo diagon√°lnƒõ).
          </div>
        ` : gameType === 'go' ? `
          <div style="margin-top: 15px; padding: 10px; background: rgba(156, 220, 254, 0.15); border-radius: 4px; font-size: 12px; color: #9cdcfe;">
            <strong style="color: #e8d5b7;">Pravidla:</strong> Obklop nep≈ô√°telsk√© kameny (odeber jim v≈°echny svobody) a ovl√°dni √∫zem√≠. 
            <strong style="color: #4ec9b0;">Sk√≥re = √∫zem√≠ + zajato.</strong>
          </div>
        ` : gameType === 'dnd' ? `
          <div style="margin-top: 15px; padding: 10px; background: rgba(206, 145, 120, 0.15); border-radius: 4px; font-size: 12px; color: #ce9178; text-align: center;">
            <strong>üí° Tip:</strong> Tvoje HP je odvozen√© od j√≠dla (${this.state.inventory.food || 0} √ó 5 = ${this.combat.playerMaxHP} HP), ale <strong style="color: #4ec9b0;">j√≠dlo se nema≈æe!</strong>
          </div>
        ` : ''}
      </div>
    `;

    document.body.appendChild(modal);
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéÆ RENDER COMBAT BOARD
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  renderCombatBoardHTML() {
    const size = this.combat.size;
    let html = '<div style="display: inline-block; background: #1a1410; padding: 10px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);">';

    for (let r = 0; r < size; r++) {
      html += '<div style="display: flex;">';
      for (let c = 0; c < size; c++) {
        const cell = this.combat.board[r][c];
        const icon = cell === 'player' ? this.combat.playerIcon : 
                     cell === 'enemy' ? this.combat.enemyIcon : '';

        html += `
          <div 
            onclick="game.handleCombatClick(${r}, ${c})" 
            style="
              width: 50px; 
              height: 50px; 
              border: 1px solid rgba(232, 213, 183, 0.2); 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              cursor: pointer;
              font-size: 24px;
              background: ${cell ? 'rgba(232, 213, 183, 0.05)' : 'transparent'};
              transition: all 0.2s;
            "
            onmouseover="if (!this.innerHTML.trim()) this.style.background='rgba(78, 200, 176, 0.1)'"
            onmouseout="if (!this.innerHTML.trim()) this.style.background='transparent'"
          >
            ${icon}
          </div>
        `;
      }
      html += '</div>';
    }

    html += '</div>';
    return html;
  },

  renderCombatBoard() {
    const container = document.getElementById('combat-board-container');
    if (container) {
      container.innerHTML = this.renderCombatBoardHTML();
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üñ±Ô∏è HANDLE COMBAT CLICK
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  handleCombatClick(row, col) {
    if (!this.combat.gameActive) return;

    // Route to appropriate handler based on game type
    if (this.combat.gameType === 'go') {
      this.handleGoClick(row, col);
      return;
    }

    // Tic-tac-toe logic
    const result = this.combat.makeMove(row, col);

    if (result === 'player_win') {
      setTimeout(() => this.handleCombatEnd(true), 500);
    } else if (result === 'draw') {
      setTimeout(() => this.handleCombatEnd(true), 500);
    } else if (result) {
      this.renderCombatBoard();
      document.getElementById('combat-status').innerHTML = 
        `Nep≈ô√≠tel p≈ôem√Ω≈°l√≠... ${this.combat.enemyIcon}`;
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ö´‚ö™ HANDLE GO CLICK
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  handleGoClick(row, col) {
    if (!this.combat.gameActive) return;
    
    // Player move
    const result = this.combat.makeMove_Go(row, col, 'player');
    
    if (!result) return; // Invalid move
    
    // Reset pass count on move
    this.combat.passCount = 0;
    
    // Update UI
    this.renderCombatBoard();
    this.renderGoStatus();
    
    // Check if game ended
    if (result === 'end') {
      const winner = this.combat.calculateGoWinner();
      setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
      return;
    }
    
    // AI move after delay
    setTimeout(() => {
      if (!this.combat.gameActive) return;
      
      const aiMove = this.combat.findGoMove();
      if (aiMove) {
        const aiResult = this.combat.makeMove_Go(aiMove.r, aiMove.c, 'enemy');
        
        // Reset pass count on move
        this.combat.passCount = 0;
        
        // Update UI
        this.renderCombatBoard();
        this.renderGoStatus();
        
        // Check if game ended
        if (aiResult === 'end') {
          const winner = this.combat.calculateGoWinner();
          setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
        }
      } else {
        // AI passes if no move found
        this.combat.pass();
        this.renderGoStatus();
        
        if (this.combat.passCount >= 2) {
          const winner = this.combat.calculateGoWinner();
          setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
        }
      }
    }, 500);
  },

  renderGoStatus() {
    const statusEl = document.getElementById('combat-status');
    const capturedEl = document.getElementById('go-captured');
    const turnsEl = document.getElementById('go-turns');
    
    if (statusEl) {
      statusEl.innerHTML = `Tv≈Øj tah: ‚ö™`;
    }
    
    if (capturedEl) {
      capturedEl.innerHTML = `‚ö™ Zajato: ${this.combat.capturedStones.player} | ‚ö´ Zajato: ${this.combat.capturedStones.enemy}`;
    }
    
    if (turnsEl) {
      const remaining = this.combat.maxTurns - this.combat.currentTurn;
      turnsEl.innerHTML = `Zb√Ωv√° tah≈Ø: ${remaining}`;
    }
  },

  handleGoPass() {
    if (!this.combat.gameActive) return;
    
    this.combat.pass();
    this.renderGoStatus();
    
    // Check if both passed
    if (this.combat.passCount >= 2) {
      const winner = this.combat.calculateGoWinner();
      setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
      return;
    }
    
    // AI move after delay
    setTimeout(() => {
      if (!this.combat.gameActive) return;
      
      const aiMove = this.combat.findGoMove();
      if (aiMove) {
        this.combat.makeMove_Go(aiMove.r, aiMove.c, 'enemy');
        this.combat.passCount = 0;
        this.renderCombatBoard();
        this.renderGoStatus();
        
        // Check if game ended
        if (this.combat.currentTurn >= this.combat.maxTurns) {
          const winner = this.combat.calculateGoWinner();
          setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
        }
      } else {
        this.combat.pass();
        this.renderGoStatus();
        
        if (this.combat.passCount >= 2) {
          const winner = this.combat.calculateGoWinner();
          setTimeout(() => this.handleCombatEnd(winner === 'player_win'), 1000);
        }
      }
    }, 500);
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé≤ HANDLE D&D ATTACK
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  handleDndAttack() {
    if (!this.combat.gameActive || this.combat.gameType !== 'dnd') return;
    
    // Disable attack button temporarily
    const btn = document.getElementById('dnd-attack-btn');
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '‚öîÔ∏è √ötoƒç√≠≈°...';
    }
    
    // Player attacks
    const playerResult = this.combat.playerAttackRoll();
    
    // Update UI
    this.renderDndCombat();
    
    // Check if enemy is defeated
    if (this.combat.enemyHP <= 0) {
      this.combat.gameActive = false;
      setTimeout(() => this.handleCombatEnd(true), 1000);
      return;
    }
    
    // Enemy counter-attack after delay
    setTimeout(() => {
      if (!this.combat.gameActive) return;
      
      const enemyResult = this.combat.enemyAttackRoll();
      
      // Update UI
      this.renderDndCombat();
      
      // Check if player is defeated
      if (this.combat.playerHP <= 0) {
        this.combat.gameActive = false;
        setTimeout(() => this.handleCombatEnd(false), 1000);
        return;
      }
      
      // Re-enable attack button
      if (btn) {
        btn.disabled = false;
        btn.innerHTML = '‚öîÔ∏è √öTOK!';
      }
    }, 1000);
  },

  renderDndCombat() {
    // Update HP bars
    const playerBar = document.getElementById('player-hp-bar');
    const enemyBar = document.getElementById('enemy-hp-bar');
    const playerText = document.getElementById('player-hp-text');
    const enemyText = document.getElementById('enemy-hp-text');
    
    if (playerBar && playerText) {
      const playerPercent = (this.combat.playerHP / this.combat.playerMaxHP) * 100;
      playerBar.style.width = `${playerPercent}%`;
      playerText.innerHTML = `üßô Ty: ${this.combat.playerHP}/${this.combat.playerMaxHP} HP`;
    }
    
    if (enemyBar && enemyText) {
      const enemyPercent = (this.combat.enemyHP / this.combat.enemyMaxHP) * 100;
      enemyBar.style.width = `${enemyPercent}%`;
      enemyText.innerHTML = `${this.combat.currentThreat.icon} ${this.combat.currentThreat.name}: ${this.combat.enemyHP}/${this.combat.enemyMaxHP} HP`;
    }
    
    // Update combat log (show last 5 entries)
    const logEl = document.getElementById('dnd-combat-log');
    if (logEl) {
      const recentLogs = this.combat.combatLog.slice(-5);
      logEl.innerHTML = recentLogs.map(entry => 
        `<div style="padding: 6px 10px; margin: 4px 0; background: rgba(20, 16, 12, 0.4); border-radius: 4px; font-size: 13px;">${entry}</div>`
      ).join('');
      // Scroll to bottom
      logEl.scrollTop = logEl.scrollHeight;
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üèÜ HANDLE COMBAT END
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  handleCombatEnd(playerWon) {
    const threat = this.combat.currentThreat;
    const outcome = playerWon ? threat.onVictory : threat.onDefeat;
    if (playerWon) {
    if (soundEffects) soundEffects.playSound('win');
    } else {
    if (soundEffects) soundEffects.playSound('lose');
    }

    // Apply consequences
    if (outcome.items) {
      for (const [itemId, value] of Object.entries(outcome.items)) {
        if (Array.isArray(value)) {
          // Range [min, max]
          const amount = Math.floor(Math.random() * (value[1] - value[0] + 1)) + value[0];
          if (amount > 0) {
            this.addItem(itemId, amount);
          } else {
            this.removeItem(itemId, Math.abs(amount));
          }
        } else {
          if (value > 0) {
            this.addItem(itemId, value);
          } else {
            this.removeItem(itemId, Math.abs(value));
          }
        }
      }
    }

    if (outcome.gold) {
      if (Array.isArray(outcome.gold)) {
        const amount = Math.floor(Math.random() * (outcome.gold[1] - outcome.gold[0] + 1)) + outcome.gold[0];
        this.state.gold += amount;
      } else if (outcome.gold < 1 && outcome.gold > -1) {
        // Percentage
        this.state.gold = Math.floor(this.state.gold * (1 + outcome.gold));
      } else {
        this.state.gold += outcome.gold;
      }
    }

    if (outcome.casualties && this.state.entities.length > 0) {
      if (Math.random() < outcome.casualties) {
        const victim = this.state.entities[Math.floor(Math.random() * this.state.entities.length)];
        this.state.entities = this.state.entities.filter(e => e.id !== victim.id);
        this.log(`üíÄ ${victim.name} zahynul v boji!`, 'danger');

        // GA4 tracking
        this.track('entity_death', {
          entity_type: victim.type,
          entity_name: victim.name,
          cause: 'combat',
          threat_id: threat.id,
          day: this.state.day
        });
      }
    }

    // Show result
    const resultModal = document.createElement('div');
    resultModal.className = 'modal-overlay';
    resultModal.style.zIndex = '10001';

    resultModal.innerHTML = `
      <div class="modal-content" style="max-width: 400px; text-align: center;">
        <div style="font-size: 72px; margin-bottom: 20px;">
          ${playerWon ? 'üéâ' : 'üíÄ'}
        </div>
        <h2 style="color: ${playerWon ? '#4ec9b0' : '#e74c3c'}; font-size: 28px; margin-bottom: 15px;">
          ${playerWon ? 'V√≠tƒõzstv√≠!' : 'Por√°≈æka!'}
        </h2>
        <p style="color: #e8d5b7; font-size: 16px; line-height: 1.6; margin-bottom: 20px;">
          ${outcome.message}
        </p>
        <button class="modal-btn modal-btn-primary" onclick="game.closeCombatResult()">
          Pokraƒçovat
        </button>
      </div>
    `;

    document.body.appendChild(resultModal);

    // Log
    this.log(outcome.message, playerWon ? 'success' : 'danger');

    // GA4 tracking
    this.track('combat_ended', {
      threat_id: threat.id,
      threat_name: threat.name,
      outcome: playerWon ? 'victory' : 'defeat',
      day: this.state.day
    });

    // Close combat modal
    this.closeModal('combat-modal');

    // Render updates
    this.render();
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üèÉ FLEE COMBAT
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  fleeCombat() {
    // üõ°Ô∏è DEFENSIVE: Check if combat is initialized
    if (!this.combat || !this.combat.currentThreat) {
      console.error('‚ùå Combat data not initialized!');
      this.log('‚ö†Ô∏è Chyba: Combat data nejsou dostupn√°', 'danger');
      this.closeModal('combat-modal');
      return;
    }

    // Show confirmation modal instead of browser confirm
    this.showFleeConfirmModal();
  },

  showFleeConfirmModal() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'flee-confirm-modal';
    
    const threat = this.combat.currentThreat;
    const outcome = threat.onDefeat;
    
    // Calculate potential losses
    let lossDescription = [];
    if (outcome.items) {
      for (const [itemId, value] of Object.entries(outcome.items)) {
        const item = this.items[itemId];
        if (!item) continue;
        
        if (Array.isArray(value)) {
          const avg = Math.floor((value[0] + value[1]) / 2 * 0.5);
          lossDescription.push(`${item.icon} ${item.name}: ~${avg}`);
        } else if (value < 0) {
          const loss = Math.ceil(Math.abs(value) * 0.5);
          lossDescription.push(`${item.icon} ${item.name}: ${loss}`);
        }
      }
    }
    
    const casualties = outcome.casualties ? `${Math.round(outcome.casualties * 50)}%` : '0%';
    
    modal.innerHTML = `
      <div class="modal-content" style="max-width: 500px;">
        <div class="modal-title" style="color: #e67e7b;">üèÉ UT√âCT Z BOJE?</div>
        
        <div style="text-align: left; color: #b89968; line-height: 1.8; margin: 25px 0;">
          
          <!-- Warning Message -->
          <div style="background: rgba(192, 80, 77, 0.15); padding: 20px; border-radius: 12px; border: 2px solid rgba(192, 80, 77, 0.4); margin-bottom: 20px;">
            <p style="font-size: 16px; font-weight: 700; color: #e67e7b; margin-bottom: 12px;">
              ‚ö†Ô∏è √ötƒõk m√° sv√© n√°sledky!
            </p>
            <p style="font-size: 14px; color: #d4a574; margin-bottom: 8px;">
              Utrp√≠≈° <strong>50% ztr√°t</strong> oproti pln√© por√°≈æce.
            </p>
            <p style="font-size: 14px; color: #d4a574;">
              Mo≈æn√° je lep≈°√≠ bojovat a≈æ do konce...
            </p>
          </div>

          <!-- Potential Losses -->
          <div style="background: rgba(20, 16, 12, 0.6); padding: 20px; border-radius: 12px; border: 1px solid rgba(139, 90, 43, 0.3);">
            <p style="font-size: 15px; font-weight: 700; color: #d4a574; margin-bottom: 15px;">
              üìä OƒåEK√ÅVAN√â ZTR√ÅTY (50%):
            </p>
            
            <div style="font-size: 13px;">
              ${lossDescription.length > 0 ? lossDescription.map(l => 
                `<div style="padding: 6px 0; border-bottom: 1px solid rgba(139, 90, 43, 0.2);">${l}</div>`
              ).join('') : '<div style="color: #8b7355;">≈Ω√°dn√© materi√°ln√≠ ztr√°ty</div>'}
              
              <div style="padding: 8px 0; margin-top: 8px; color: #e67e7b; font-weight: 600;">
                üíÄ Riziko √∫mrt√≠ kolonistu: ${casualties}
              </div>
            </div>
          </div>
        </div>
        
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-secondary" onclick="game.closeModal('flee-confirm-modal')">
            ‚öîÔ∏è Z≈Østat a bojovat
          </button>
          <button class="modal-btn modal-btn-danger" onclick="game.confirmFlee()" style="background: linear-gradient(135deg, #c0504d, #e67e7b); border-color: rgba(230, 126, 123, 0.5);">
            üèÉ Opravdu ut√©ct
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
  },

  confirmFlee() {
    // Close confirmation modal
    this.closeModal('flee-confirm-modal');

    const threat = this.combat.currentThreat;
    const outcome = threat.onDefeat;

    // Apply 50% of defeat consequences
    if (outcome.items) {
      for (const [itemId, value] of Object.entries(outcome.items)) {
        if (Array.isArray(value)) {
          const amount = Math.floor((Math.random() * (value[1] - value[0] + 1)) + value[0]) * 0.5;
          this.removeItem(itemId, Math.ceil(Math.abs(amount)));
        } else if (value < 0) {
          this.removeItem(itemId, Math.ceil(Math.abs(value) * 0.5));
        }
      }
    }

    if (outcome.casualties && this.state.entities.length > 0) {
      if (Math.random() < (outcome.casualties * 0.5)) {
        const victim = this.state.entities[Math.floor(Math.random() * this.state.entities.length)];
        this.state.entities = this.state.entities.filter(e => e.id !== victim.id);
        this.log(`üíÄ ${victim.name} zahynul p≈ôi √∫tƒõku!`, 'danger');
      }
    }

    this.log(`üèÉ Uprchl jsi z boje! Ale s tƒõ≈æk√Ωmi ztr√°tami...`, 'warning');

    // GA4 tracking
    this.track('combat_fled', {
      threat_id: threat.id,
      threat_name: threat.name,
      day: this.state.day
    });

    this.closeModal('combat-modal');
    this.render();
  },

  closeCombatResult() {
    const modals = document.querySelectorAll('.modal-overlay');
    modals.forEach(m => m.remove());
    this.closeModal('combat-modal');
  },

};

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéµ ATMOSPHERIC MUSIC SYSTEM with Seasonal Tracks
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class AtmosphericMusic {
      constructor() {
        // üì± DEVICE DETECTION - Mobile vs Desktop
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                      || (window.innerWidth <= 768);
        
        // üéöÔ∏è AUDIO SETTINGS podle za≈ô√≠zen√≠
        const audioSettings = isMobile ? {
          sampleRate: 22050,    // üì± Mobil: ni≈æ≈°√≠ sample rate
          latencyHint: 'playback',
          bufferDuration: 8     // 8s buffer proti prask√°n√≠
        } : {
          sampleRate: 44100,    // üíª PC: pln√Ω zvuk
          latencyHint: 'playback',
          bufferDuration: 4     // 4s buffer
        };
        
        console.log(`üéµ Audio: ${isMobile ? 'üì± Mobile' : 'üíª Desktop'} mode - ${audioSettings.sampleRate}Hz, ${audioSettings.bufferDuration}s buffer`);
        
        // Create AudioContext s adaptive settings
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: audioSettings.sampleRate,
          latencyHint: audioSettings.latencyHint
        });
        
        this.bufferDuration = audioSettings.bufferDuration;
        this.isMobile = isMobile;
        
        this.masterGain = this.audioContext.createGain();
        
        const savedVolume = localStorage.getItem('musicVolume') || 30;
        this.masterGain.gain.value = savedVolume / 100;
        
        this.masterGain.connect(this.audioContext.destination);
        
        this.isPlaying = false;
        this.isMuted = false; // üîá GLOBAL MUTE FLAG
        this.currentTrack = null;
        this.currentSeason = 0; // 0=spring, 1=summer, 2=autumn, 3=winter
        
        // Track definitions with medieval names
        this.tracks = {
          spring: [
            {
              name: 'üå∏ Ambient Jara - Tich√© Procit√°n√≠',
              duration: 600, // 10 minutes
              instruments: ['deep_bass', 'sparse_chimes'],
              tempo: 'very_slow' // ~60 BPM
            },
            {
              name: 'üå∏ P√≠se≈à Jarn√≠ho Procitnut√≠',
              duration: 600,
              instruments: ['flute', 'harp', 'bells'],
              tempo: 'slow'
            }
          ],
          summer: [
			{
			  name: '‚òÄÔ∏è Tanec Sluneƒçn√≠ho Kr√°le',
              duration: 600,
              instruments: ['lute', 'tambourine', 'triangle'],
              tempo: 'lively'
			},
			{
			  name: 'üå∏ P√≠se≈à Jarn√≠ho Procitnut√≠2',
              duration: 600,
              instruments: ['flute', 'harp', 'bells'],
              tempo: 'slow'
            }
		  ],
          autumn: [
			{
			  name: 'üçÇ Balada Padaj√≠c√≠ho List√≠',
              duration: 600,
              instruments: ['harp', 'crotals', 'sistrum'],
              tempo: 'slow'
			},
			{
              name: 'üçÇ Balada Padaj√≠c√≠ho List√≠2',
              duration: 600,
              instruments: ['harp', 'crotals', 'sistrum'],
              tempo: 'slow'
            }
		  ],
          winter: [
			{
			  name: '‚ùÑÔ∏è Koleda Mraziv√Ωch Noc√≠',
              duration: 600,
              instruments: ['bells', 'chimes', 'cymbals'],
              tempo: 'solemn'
			},
			{
			  name: '‚ùÑÔ∏è Koleda Mraziv√Ωch Noc√≠2',
              duration: 600,
              instruments: ['bells', 'chimes', 'cymbals'],
              tempo: 'solemn'
			}
		  ]
        };
        
        this.scheduledNotes = [];
        this.startTime = 0;
        this.currentTrackIndex = 0; // Pro playlist
        this.activeOscillators = []; // Pro stopov√°n√≠ aktivn√≠ch not
        this.trackTimeout = null; // Pro canceling pl√°novan√©ho loopu
      }

      // Generate notes for specific instrument type
      generateInstrumentNotes(instrument, duration, startTime) {
        const notes = [];
        const baseFreq = 220; // A3
        
        switch(instrument) {
          case 'deep_bass':
            // Deep ambient bass drone (70 BPM max)
            // Dlouh√©, pomalu se mƒõn√≠c√≠ basov√© t√≥ny
            const bassDuration = duration;
            const chordChangeDuration = 16; // Zmƒõna ka≈æd√Ωch 16 sekund
            
            for (let t = 0; t < bassDuration; t += chordChangeDuration) {
              // Basov√© akordick√© t√≥ny (pentatonika v C)
              const bassNotes = [
                [65.41, 82.41],   // C2 + E2
                [73.42, 87.31],   // D2 + F2
                [98.00, 123.47],  // G2 + B2
                [82.41, 110.00]   // E2 + A2
              ];
              
              const chord = bassNotes[Math.floor(Math.random() * bassNotes.length)];
              
              // Ka≈æd√Ω t√≥n v akordu
              chord.forEach((freq, i) => {
                notes.push({
                  time: startTime + t + (i * 0.5), // M√≠rn√Ω stagger
                  frequency: freq,
                  duration: chordChangeDuration + 2, // P≈ôekryv
                  type: 'sine',
                  instrument: 'deep_bass',
                  volume: 0.15 + (Math.random() * 0.05) // Jemn√© kol√≠s√°n√≠
                });
              });
            }
            break;

          case 'sparse_chimes':
            // Kakofonick√©, ≈ô√≠dk√© cink√°n√≠ (70 BPM = 0.857s na beat)
            const beatInterval = 60 / 70; // ~0.857 sekund
            
            for (let t = 0; t < duration; t += beatInterval * 4) { // Ka≈æd√Ω 4. beat
              if (Math.random() > 0.4) { // 60% ≈°ance na zahr√°n√≠
                
                // N√°hodn√© frekvence z lydick√© ≈°k√°ly (√©terick√©)
                const chimeFreqs = [
                  523.25, // C5
                  587.33, // D5
                  659.25, // E5
                  739.99, // F#5 (lydick√©)
                  783.99, // G5
                  880.00, // A5
                  987.77, // B5
                  1046.50 // C6
                ];
                
                // Vyberu 1-3 n√°hodn√© t√≥ny najednou (kakofonick√Ω efekt)
                const numNotes = Math.floor(Math.random() * 3) + 1;
                const selectedFreqs = [];
                
                for (let n = 0; n < numNotes; n++) {
                  selectedFreqs.push(chimeFreqs[Math.floor(Math.random() * chimeFreqs.length)]);
                }
                
                selectedFreqs.forEach((freq, i) => {
                  notes.push({
                    time: startTime + t + (i * 0.05), // Velmi m√≠rn√Ω stagger
                    frequency: freq * (0.98 + Math.random() * 0.04), // Detuning
                    duration: 3 + Math.random() * 2, // 3-5 sekund (dlouh√© dozn√≠v√°n√≠)
                    type: 'sine',
                    instrument: 'sparse_chimes',
                    shimmer: true,
                    volume: 0.1 + (Math.random() * 0.08) // Jemn√° hlasitost
                  });
                });
              }
            }
            break;
            
          case 'flute':
            // Light, airy melody
            for (let t = 0; t < duration; t += 0.8) {
              const scale = [0, 2, 4, 5, 7, 9, 11, 12];
              const note = scale[Math.floor(Math.random() * scale.length)];
              notes.push({
                time: startTime + t,
                frequency: baseFreq * Math.pow(2, (note + 12) / 12),
                duration: 0.6,
                type: 'sine',
                instrument: 'flute'
              });
            }
            break;
            
          case 'harp':
            // Arpeggiated chords
            for (let t = 0; t < duration; t += 1.5) {
              const chord = [0, 4, 7, 12];
              chord.forEach((note, i) => {
                notes.push({
                  time: startTime + t + (i * 0.15),
                  frequency: baseFreq * Math.pow(2, note / 12),
                  duration: 1.2,
                  type: 'triangle',
                  instrument: 'harp'
                });
              });
            }
            break;
            
          case 'bells':
            // Chiming bells
            for (let t = 0; t < duration; t += 2.5) {
              const bellNotes = [0, 7, 12, 19];
              const note = bellNotes[Math.floor(Math.random() * bellNotes.length)];
              notes.push({
                time: startTime + t,
                frequency: baseFreq * 2 * Math.pow(2, note / 12),
                duration: 2.0,
                type: 'sine',
                instrument: 'bells',
                shimmer: true
              });
            }
            break;
            
          case 'lute':
            // Plucked strings
            for (let t = 0; t < duration; t += 0.5) {
              const scale = [0, 2, 3, 5, 7, 8, 10];
              const note = scale[Math.floor(Math.random() * scale.length)];
              notes.push({
                time: startTime + t,
                frequency: baseFreq * Math.pow(2, note / 12),
                duration: 0.4,
                type: 'triangle',
                instrument: 'lute',
                pluck: true
              });
            }
            break;
            
          case 'tambourine':
            // Rhythmic jingles
            for (let t = 0; t < duration; t += 0.25) {
              if (Math.random() > 0.3) {
                notes.push({
                  time: startTime + t,
                  frequency: 2000 + Math.random() * 1000,
                  duration: 0.1,
                  type: 'square',
                  instrument: 'tambourine',
                  noise: true
                });
              }
            }
            break;
            
          case 'triangle':
            // Clear metallic pings
            for (let t = 0; t < duration; t += 3) {
              notes.push({
                time: startTime + t,
                frequency: 2500,
                duration: 1.5,
                type: 'sine',
                instrument: 'triangle',
                metallic: true
              });
            }
            break;
            
          case 'crotals':
            // Small cymbals
            for (let t = 0; t < duration; t += 1.2) {
              notes.push({
                time: startTime + t,
                frequency: 1800 + Math.random() * 500,
                duration: 0.8,
                type: 'square',
                instrument: 'crotals',
                shimmer: true
              });
            }
            break;
            
          case 'chimes':
            // Bell chimes cascade
            for (let t = 0; t < duration; t += 4) {
              const chimeNotes = [0, 2, 4, 7, 9, 12];
              chimeNotes.forEach((note, i) => {
                notes.push({
                  time: startTime + t + (i * 0.2),
                  frequency: baseFreq * 3 * Math.pow(2, note / 12),
                  duration: 2.0,
                  type: 'sine',
                  instrument: 'chimes',
                  shimmer: true
                });
              });
            }
            break;
            
          case 'cymbals':
            // Accent hits
            for (let t = 0; t < duration; t += 8) {
              notes.push({
                time: startTime + t,
                frequency: 3000,
                duration: 3.0,
                type: 'square',
                instrument: 'cymbals',
                noise: true,
                metallic: true
              });
            }
            break;
            
          case 'sistrum':
            // Rattling metal
            for (let t = 0; t < duration; t += 0.15) {
              if (Math.random() > 0.4) {
                notes.push({
                  time: startTime + t,
                  frequency: 1500 + Math.random() * 2000,
                  duration: 0.08,
                  type: 'square',
                  instrument: 'sistrum',
                  noise: true
                });
              }
            }
            break;
        }
        
        return notes;
      }

      playNote(note) {
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.type = note.type;
        osc.frequency.value = note.frequency;
        
        // Special effects
        if (note.shimmer) {
          const lfo = this.audioContext.createOscillator();
          const lfoGain = this.audioContext.createGain();
          lfo.frequency.value = 5;
          lfoGain.gain.value = 3;
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);
          lfo.start();
          lfo.stop(note.time + note.duration);
        }
        
        // Use custom volume if provided, otherwise use defaults
        const baseVolume = note.volume || 0.08;
        
        if (note.pluck) {
          gain.gain.setValueAtTime(baseVolume * 3.75, note.time);
          gain.gain.exponentialRampToValueAtTime(0.01, note.time + note.duration);
        } else if (note.metallic) {
          gain.gain.setValueAtTime(baseVolume * 1.875, note.time);
          gain.gain.exponentialRampToValueAtTime(0.01, note.time + note.duration);
        } else if (note.noise) {
          gain.gain.setValueAtTime(baseVolume * 0.625, note.time);
          gain.gain.exponentialRampToValueAtTime(0.001, note.time + note.duration);
        } else {
          gain.gain.setValueAtTime(baseVolume, note.time);
          gain.gain.linearRampToValueAtTime(baseVolume * 1.5, note.time + note.duration * 0.3);
          gain.gain.exponentialRampToValueAtTime(0.01, note.time + note.duration);
        }
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start(note.time);
        osc.stop(note.time + note.duration);
        
        // Sleduj aktivn√≠ oscil√°tory
        this.activeOscillators.push({ osc, gain });
        
        // Auto-cleanup po skonƒçen√≠ noty
        setTimeout(() => {
          const index = this.activeOscillators.findIndex(item => item.osc === osc);
          if (index > -1) {
            this.activeOscillators.splice(index, 1);
          }
        }, (note.time - this.audioContext.currentTime + note.duration) * 1000 + 100);
      }

      generateTrack(seasonKey) {
        const playlist = this.tracks[seasonKey];
        const notes = [];
        
        // Pokud je to playlist, vyberu aktu√°ln√≠ track
        let track;
        if (Array.isArray(playlist)) {
          track = playlist[this.currentTrackIndex];
        } else {
          track = playlist;
        }
        
        track.instruments.forEach(instrument => {
          const instrumentNotes = this.generateInstrumentNotes(
            instrument,
            track.duration,
            this.audioContext.currentTime
          );
          notes.push(...instrumentNotes);
        });
        
        return notes;
      }

      stopAllNotes() {
        // Zastav√≠ v≈°echny aktivn√≠ oscil√°tory s fade-outem
        const now = this.audioContext.currentTime;
        const fadeTime = 0.5; // 500ms fade out
        
        this.activeOscillators.forEach(({ osc, gain }) => {
          try {
            // Fade out
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(gain.gain.value, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + fadeTime);
            
            // Stop oscillator after fade
            osc.stop(now + fadeTime);
          } catch (e) {
            // Already stopped, ignore
          }
        });
        
        // Vyƒçisti pole
        setTimeout(() => {
          this.activeOscillators = [];
        }, fadeTime * 1000 + 100);
      }

      play(seasonIndex = 0, forceFirstTrack = false) {
        // üîá Pokud je muted, nep≈ôehr√°vej
        if (this.isMuted) {
          console.log('üîá Music muted, not playing');
          return;
        }
        
        // Zastav v≈°echny star√© noty s fade-outem (pokud nƒõco hraje)
        if (this.activeOscillators.length > 0) {
          this.stopAllNotes();
          // Poƒçkej na fade-out p≈ôed p≈ôehr√°n√≠m nov√©ho tracku
          setTimeout(() => {
            this.playTrack(seasonIndex, forceFirstTrack);
          }, 600); // 500ms fade + 100ms buffer
        } else {
          this.playTrack(seasonIndex, forceFirstTrack);
        }
      }

	  nextTrack() {
        if (this.isMuted) return;
        // Zavol√°me playTrack s p≈ô√≠znakem isManualSkip = true
        this.playTrack(this.currentSeason, false, true);
      }
	
	  playTrack(seasonIndex, forceFirstTrack = false, isManualSkip = false) {
        // Pokud u≈æ hraje a NEN√ç to manu√°ln√≠ p≈ôeskoƒçen√≠, nic nedƒõlej
        if (this.isPlaying && !isManualSkip) return;
        
        // Pokud je to manu√°ln√≠ p≈ôeskoƒçen√≠, zastav√≠me star√© t√≥ny a timeouty
        if (isManualSkip) {
          if (this.trackTimeout) clearTimeout(this.trackTimeout);
          this.stopAllNotes();
          this.isPlaying = false;
        }

        const seasons = ['spring', 'summer', 'autumn', 'winter'];
		this.currentSeason = seasonIndex;
		const seasonKey = seasons[this.currentSeason];
		const playlist = this.tracks[seasonKey];

		if (Array.isArray(playlist) && playlist.length > 0) {
			// Pokud jde o manu√°ln√≠ p≈ôeskoƒçen√≠, mus√≠me zastavit aktu√°ln√≠ produkci
			if (isManualSkip) {
				if (this.trackTimeout) clearTimeout(this.trackTimeout);
				this.stopAllNotes(); // Toto zastav√≠ aktu√°lnƒõ znƒõj√≠c√≠ t√≥ny
				this.isPlaying = false; 
      
			// V√Ωpoƒçet dal≈°√≠ho indexu
			this.currentTrackIndex = (this.currentTrackIndex + 1) % playlist.length;
			} else if (forceFirstTrack) {
				this.currentTrackIndex = 0;
			} else {
				this.currentTrackIndex = Math.floor(Math.random() * playlist.length);
			}
          
          const track = playlist[this.currentTrackIndex];
          
          console.log(`üéµ Playing: ${track.name} (${this.currentTrackIndex + 1}/${playlist.length})`);
          
          this.startTime = this.audioContext.currentTime;
          this.scheduledNotes = this.generateTrack(seasonKey);
          
          this.scheduledNotes.forEach(note => {
            this.playNote(note);
          });
          
          this.isPlaying = true;
          
          // Update UI with track name
          this.updateTrackDisplay(seasonKey);
          
          // Loop after track ends - vybere dal≈°√≠ n√°hodn√Ω track
          const trackDuration = track.duration * 1000;
          this.trackTimeout = setTimeout(() => {
            this.isPlaying = false;
            const audioMuted = localStorage.getItem('allAudioMuted') === 'true';
            if (!audioMuted && !this.isMuted) {
              this.play(this.currentSeason); // Loop bez forceFirstTrack = random
            }
          }, trackDuration);
        } else {
          // Fallback pro backward compatibility (single track)
          this.startTime = this.audioContext.currentTime;
          this.scheduledNotes = this.generateTrack(seasonKey);
          
          this.scheduledNotes.forEach(note => {
            this.playNote(note);
          });
          
          this.isPlaying = true;
          this.updateTrackDisplay(seasonKey);
          
          const trackDuration = playlist.duration * 1000;
          this.trackTimeout = setTimeout(() => {
            this.isPlaying = false;
            const audioMuted = localStorage.getItem('allAudioMuted') === 'true';
            if (!audioMuted && !this.isMuted) {
              this.play(this.currentSeason);
            }
          }, trackDuration);
        }
      }

      updateTrackDisplay(seasonKey) {
        const playlist = this.tracks[seasonKey];
        let trackName = '';
        
        if (Array.isArray(playlist)) {
          const track = playlist[this.currentTrackIndex];
          trackName = track.name;
        } else {
          trackName = playlist.name;
        }
        
        const label = document.getElementById('track-name');
        if (label) {
          label.textContent = trackName;
          // Keep visible in footer (no fade out)
        }
      }

      stop() {
        this.isPlaying = false;
        this.activeOscillators = []; // Vyƒçisti pole oscil√°tor≈Ø
        
        // Zru≈° napl√°novan√Ω loop
        if (this.trackTimeout) {
          clearTimeout(this.trackTimeout);
          this.trackTimeout = null;
        }
        
        this.audioContext.close();
        
        // üéöÔ∏è Recreate AudioContext s adaptive settings (same as constructor)
        const audioSettings = this.isMobile ? {
          sampleRate: 22050,
          latencyHint: 'playback'
        } : {
          sampleRate: 44100,
          latencyHint: 'playback'
        };
        
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: audioSettings.sampleRate,
          latencyHint: audioSettings.latencyHint
        });
        
        this.masterGain = this.audioContext.createGain();
        const savedVolume = localStorage.getItem('musicVolume') || 30;
        this.masterGain.gain.value = savedVolume / 100;
        this.masterGain.connect(this.audioContext.destination);
      }

      toggle() {
        if (this.isPlaying) {
          // Currently playing -> STOP
          this.stop();
        } else {
          // Not playing -> START
          this.play(this.currentSeason, true); // forceFirstTrack = true
        }
      }

      setVolume(value) {
        this.masterGain.gain.value = value / 100;
        localStorage.setItem('musicVolume', value);
        document.getElementById('volume-label').textContent = value + '%';
      }

      changeSeason(seasonIndex) {
        if (seasonIndex !== this.currentSeason && this.isPlaying) {
          console.log(`üçÇ Season change: ${this.currentSeason} ‚Üí ${seasonIndex}`);
          
          // Zru≈° napl√°novan√Ω loop souƒçasn√©ho tracku
          if (this.trackTimeout) {
            clearTimeout(this.trackTimeout);
            this.trackTimeout = null;
          }
          
          // Zastav souƒçasn√Ω track s fade-outem
          this.isPlaying = false; // Oznaƒç jako "zastavuj√≠c√≠ se"
          
          if (this.activeOscillators.length > 0) {
            this.stopAllNotes();
            
            // Po fade-outu spus≈• nov√Ω track pro novou sez√≥nu (V≈ΩDY prvn√≠ track)
            setTimeout(() => {
              this.currentSeason = seasonIndex;
              this.play(seasonIndex, true); // forceFirstTrack = true
            }, 600);
          } else {
            // ≈Ω√°dn√© aktivn√≠ noty, spus≈• rovnou
            this.currentSeason = seasonIndex;
            this.play(seasonIndex, true); // forceFirstTrack = true
          }
        } else if (seasonIndex !== this.currentSeason && !this.isPlaying) {
          // Pokud nehraje, jen updatuj currentSeason
          this.currentSeason = seasonIndex;
        }
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üîä SOUND EFFECTS SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    class SoundEffects {
      constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.audioContext.destination);
        this.isMuted = false; // üîá GLOBAL MUTE FLAG
      }

      playSound(type) {
        // üîá Pokud je muted, nepi≈° zvuk
        if (this.isMuted) return;
        
        const now = this.audioContext.currentTime;
        
        switch(type) {
          case 'craft':
            this.playCraftSound(now);
            break;
          case 'gather':
            this.playGatherSound(now);
            break;
          case 'nextDay':
            this.playNextDaySound(now);
            break;
          case 'combat':
            this.playCombatSound(now);
            break;
          case 'win':
            this.playWinSound(now);
            break;
          case 'lose':
            this.playLoseSound(now);
            break;
          case 'buy':
            this.playBuySound(now);
            break;
          case 'sell':
            this.playSellSound(now);
            break;
          case 'alert':
            this.playAlertSound(now);
            break;
        }
      }

      playCraftSound(time) {
        // Hammer hitting anvil
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        
        osc.type = 'square';
        osc.frequency.value = 150;
        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(time);
        osc.stop(time + 0.1);
        
        // Second hit
        const osc2 = this.audioContext.createOscillator();
        const gain2 = this.audioContext.createGain();
        osc2.type = 'square';
        osc2.frequency.value = 180;
        gain2.gain.setValueAtTime(0.3, time + 0.15);
        gain2.gain.exponentialRampToValueAtTime(0.01, time + 0.25);
        osc2.connect(gain2);
        gain2.connect(this.masterGain);
        osc2.start(time + 0.15);
        osc2.stop(time + 0.25);
      }

      playGatherSound(time) {
        // Rustling/picking sound
        for (let i = 0; i < 3; i++) {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.type = 'sine';
          osc.frequency.value = 800 + Math.random() * 400;
          gain.gain.setValueAtTime(0.1, time + i * 0.05);
          gain.gain.exponentialRampToValueAtTime(0.01, time + i * 0.05 + 0.1);
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start(time + i * 0.05);
          osc.stop(time + i * 0.05 + 0.1);
        }
      }
		playNextDaySound(time) {
		  // üò¥ CHR√ÅP√ÅN√ç star≈°√≠ mu≈æsk√© osoby (max 2s)
		  const duration = 1.1;
		  
		  // 1. White noise jako z√°klad
		  const bufferSize = this.audioContext.sampleRate * duration;
		  const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
		  const data = buffer.getChannelData(0);
		  
		  for (let i = 0; i < bufferSize; i++) {
			data[i] = Math.random() * 1 - 1;
		  }
		  
		  const noise = this.audioContext.createBufferSource();
		  noise.buffer = buffer;
		  
		  // 2. BandPass filter (80-300 Hz)
		  const bandpass = this.audioContext.createBiquadFilter();
		  bandpass.type = 'bandpass';
		  bandpass.frequency.value = 150;
		  bandpass.Q.value = 1;
		  
		  // 3. LowPass filter (400 Hz)
		  const lowpass = this.audioContext.createBiquadFilter();
		  lowpass.type = 'lowpass';
		  lowpass.frequency.value = 200;
		  lowpass.Q.value = 1;
		  
		  // 4. LFO modulace (7 Hz vibrace)
		  const lfo = this.audioContext.createOscillator();
		  lfo.frequency.value = 7;
		  lfo.type = 'sine';
		  
		  const lfoGain = this.audioContext.createGain();
		  lfoGain.gain.value = 0.3;
		  
		  // 5. Gain envelope
		  const gain = this.audioContext.createGain();
		  gain.gain.setValueAtTime(0, time);
		  gain.gain.linearRampToValueAtTime(0.15, time + 0.3);
		  gain.gain.setValueAtTime(0.15, time + 1.2);
		  gain.gain.linearRampToValueAtTime(0, time + duration);
		  
		  // 6. Connect chain
		  noise.connect(bandpass);
		  bandpass.connect(lowpass);
		  lowpass.connect(gain);
		  lfo.connect(lfoGain);
		  lfoGain.connect(gain.gain);
		  gain.connect(this.masterGain);
		  
		  // 7. Start
		  noise.start(time);
		  lfo.start(time);
		  noise.stop(time + duration);
		  lfo.stop(time + duration);
		}

      playCombatSound(time) {
        // Sword clash
        const osc = this.audioContext.createOscillator();
        const gain = this.audioContext.createGain();
        osc.type = 'square';
        osc.frequency.value = 300;
        gain.gain.setValueAtTime(0.4, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start(time);
        osc.stop(time + 0.2);
      }

      playWinSound(time) {
        // Victory fanfare
        const notes = [523, 659, 784, 1047]; // C-E-G-C
        notes.forEach((freq, i) => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.2, time + i * 0.15);
          gain.gain.exponentialRampToValueAtTime(0.01, time + i * 0.15 + 0.4);
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start(time + i * 0.15);
          osc.stop(time + i * 0.15 + 0.4);
        });
      }

      playLoseSound(time) {
        // Descending sad notes
        const notes = [392, 349, 330, 294]; // G-F-E-D
        notes.forEach((freq, i) => {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.15, time + i * 0.2);
          gain.gain.exponentialRampToValueAtTime(0.01, time + i * 0.2 + 0.5);
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start(time + i * 0.2);
          osc.stop(time + i * 0.2 + 0.5);
        });
      }

      playBuySound(time) {
        // Cash register cha-ching
        const osc1 = this.audioContext.createOscillator();
        const gain1 = this.audioContext.createGain();
        osc1.type = 'sine';
        osc1.frequency.value = 1000;
        gain1.gain.setValueAtTime(0.2, time);
        gain1.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
        osc1.connect(gain1);
        gain1.connect(this.masterGain);
        osc1.start(time);
        osc1.stop(time + 0.3);
        
        const osc2 = this.audioContext.createOscillator();
        const gain2 = this.audioContext.createGain();
        osc2.type = 'sine';
        osc2.frequency.value = 1200;
        gain2.gain.setValueAtTime(0.2, time + 0.1);
        gain2.gain.exponentialRampToValueAtTime(0.01, time + 0.4);
        osc2.connect(gain2);
        gain2.connect(this.masterGain);
        osc2.start(time + 0.1);
        osc2.stop(time + 0.4);
      }

      playSellSound(time) {
        // Coins clinking
        for (let i = 0; i < 4; i++) {
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.type = 'triangle';
          osc.frequency.value = 800 + Math.random() * 200;
          gain.gain.setValueAtTime(0.15, time + i * 0.08);
          gain.gain.exponentialRampToValueAtTime(0.01, time + i * 0.08 + 0.15);
          osc.connect(gain);
          gain.connect(this.masterGain);
          osc.start(time + i * 0.08);
          osc.stop(time + i * 0.08 + 0.15);
        }
      }
	  playAlertSound(time) {
		// Create a longer, more pleasant chime sound
		for (let i = 0; i < 3; i++) { // Reduced number of chimes for a cleaner sound
			const osc = this.audioContext.createOscillator();
			const gain = this.audioContext.createGain();
			// Use sine wave for a more pleasant chime sound
			osc.type = 'sine';
			// Use a lower frequency range for a deeper, more resonant chime
			osc.frequency.value = 300 + Math.random() * 100;
			// Set the initial gain and create a more gradual fade-out
			gain.gain.setValueAtTime(0.2, time + i * 0.3); // Increased interval between chimes
			gain.gain.exponentialRampToValueAtTime(0.01, time + i * 0.3 + 2.0); // Extended duration
			osc.connect(gain);
			gain.connect(this.masterGain);
			osc.start(time + i * 0.3);
			osc.stop(time + i * 0.3 + 2.0); // Extended duration
		}
	}

    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üî• FIRE CRACKLING SOUND SYSTEM
    // Procedur√°ln√≠ generov√°n√≠ praskan√≠ ohnƒõ
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    class FireCrackle {
      constructor() {
        // Pou≈æijeme stejn√Ω AudioContext jako AtmosphericMusic
        this.audioContext = window.atmosphericMusic ? window.atmosphericMusic.audioContext : new AudioContext();
        
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0; // Start silent
        this.masterGain.connect(this.audioContext.destination);
        
        this.isPlaying = false;
        this.crackleInterval = null;
        this.volume = 0.25; // Target volume
      }
      
      // Start fire crackling
      start() {
        if (this.isPlaying) return;
        
        // Resume AudioContext if suspended (browser autoplay policy)
        if (this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }
        
        this.isPlaying = true;
        
        // Fade in to target volume
        this.masterGain.gain.setTargetAtTime(this.volume, this.audioContext.currentTime, 0.5);
        
        // Random crackles only (no rumble)
        this.scheduleCrackles();
        
        console.log('üî• Fire crackling started');
      }
      
      // Stop fire crackling
      stop() {
        if (!this.isPlaying) return;
        
        this.isPlaying = false;
        
        // Fade out
        this.masterGain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.5);
        
        // Clear crackle scheduler
        if (this.crackleInterval) {
          clearInterval(this.crackleInterval);
          this.crackleInterval = null;
        }
        
        console.log('üî• Fire crackling stopped');
      }
      
      // Schedule random crackles
      scheduleCrackles() {
        this.crackleInterval = setInterval(() => {
          if (!this.isPlaying) return;
          
          // Random crackle frequency (1-3 per second)
          const numCrackles = Math.floor(Math.random() * 3) + 1;
          
          for (let i = 0; i < numCrackles; i++) {
            setTimeout(() => {
              this.playCrackle();
            }, Math.random() * 1000); // Spread within 1 second
          }
        }, 1000);
      }
      
      // Single crackle sound
      playCrackle() {
        if (!this.isPlaying) return; // Safety check
        
        const now = this.audioContext.currentTime;
        
        // Noise-based crackle
        const bufferSize = this.audioContext.sampleRate * 0.1; // 100ms
        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate noise with envelope
        for (let i = 0; i < bufferSize; i++) {
          const t = i / bufferSize;
          const envelope = Math.exp(-t * 10); // Fast decay
          data[i] = (Math.random() * 2 - 1) * envelope;
        }
        
        const noise = this.audioContext.createBufferSource();
        noise.buffer = buffer;
        
        // Bandpass filter for "woody" crackle
        const filter = this.audioContext.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800 + Math.random() * 1200; // 800-2000 Hz
        filter.Q.value = 2;
        
        const gain = this.audioContext.createGain();
        gain.gain.value = 0.3 + Math.random() * 0.4; // Random intensity
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        noise.start(now);
      }
    }
    
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéµ INITIALIZE GAME & MUSIC SYSTEM
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üîä GLOBAL AUDIO CONTROL
      // Ovl√°d√° V≈†ECHNY zvuky (hudba + sound effects)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function toggleAllAudio() {
        const isCurrentlyMuted = localStorage.getItem('allAudioMuted') === 'true';
        const newMutedState = !isCurrentlyMuted;
        
        // Update localStorage
        localStorage.setItem('allAudioMuted', newMutedState);
        
        // Update button
        document.getElementById('music-toggle-btn').textContent = newMutedState ? 'üîá' : 'üîä';
        
        if (newMutedState) {
          // MUTE ALL AUDIO
          console.log('üîá V≈°echny zvuky vypnuty');
          
          // Mute music
          if (window.atmosphericMusic) {
            window.atmosphericMusic.isMuted = true;
            if (window.atmosphericMusic.isPlaying) {
              window.atmosphericMusic.stop();
            }
          }
          
          // Mute sound effects
          if (window.soundEffects) {
            window.soundEffects.isMuted = true;
          }
          
          // üî• Mute fire crackle
          if (window.fireCrackle) {
            window.fireCrackle.stop();
          }
          
        } else {
          // UNMUTE ALL AUDIO
          console.log('üîä V≈°echny zvuky zapnuty');
          
          // Unmute music
          if (window.atmosphericMusic) {
            window.atmosphericMusic.isMuted = false;
            // Auto-start music pokud hra u≈æ bƒõ≈æ√≠
            if (game && game.state && game.state.day > 1) {
              window.atmosphericMusic.play(game.state.season, true);
            }
          }
          
          // Unmute sound effects
          if (window.soundEffects) {
            window.soundEffects.isMuted = false;
          }
          
          // üî• Restart fire crackle if fire is active
          if (window.fireCrackle && game && game.state && game.state.fireActive) {
            window.fireCrackle.start();
          }
        }
      }

    let soundEffects = null;
    window.onload = () => {
      // Initialize game
      game.init();

      // Initialize music system
      window.atmosphericMusic = new AtmosphericMusic();
      soundEffects = new SoundEffects();
      window.soundEffects = soundEffects; // Make globally accessible
      
      // üî• Initialize fire crackling
      window.fireCrackle = new FireCrackle();

      // üîá Load global mute state
      const allAudioMuted = localStorage.getItem('allAudioMuted') === 'true';
      
      if (allAudioMuted) {
        // Apply mute state
        window.atmosphericMusic.isMuted = true;
        window.soundEffects.isMuted = true;
        document.getElementById('music-toggle-btn').textContent = 'üîá';
      } else {
        window.atmosphericMusic.isMuted = false;
        window.soundEffects.isMuted = false;
        document.getElementById('music-toggle-btn').textContent = 'üîä';
      }
      
      // DON'T auto-play on load - let user start with Next Day or toggle button
    }
    </script>  <!-- KONEC JavaScriptu -->


</body>
</html>
